[
  {
    "id": "scenario_shell_scripting_advanced_137",
    "command": "bash",
    "scenario": "Write advanced bash scripts with functions, error handling, and best practices.",
    "problem": "Need to automate complex tasks, write maintainable scripts, handle errors properly, accept command-line arguments, use functions for reusability, implement logging, and follow shell scripting best practices.",
    "solution": "Master bash scripting with functions, error handling (set -e, trap), argument parsing, arrays, conditionals, loops, input validation, logging, and modular design for robust automation scripts.",
    "steps": [
      "USER SAYS: 'I can write basic bash scripts but need to make them more robust with error handling, functions, and proper argument parsing. What are the best practices?'",
      "AGENT: 'Let me show you advanced bash scripting! We'll cover functions, error handling, argument parsing, arrays, and professional script structure.'",
      "AGENT: ''",
      "AGENT: '🔍 RESEARCH PHASE: Advanced bash scripting...'",
      "AGENT: '[Searching] \"bash scripting best practices error handling functions\"'",
      "AGENT: '[Found] set -euo pipefail for strict error handling.'",
      "AGENT: '[Found] Functions for code reusability and organization.'",
      "AGENT: '[Found] trap for cleanup on exit/error.'",
      "AGENT: '[Found] getopts for option parsing, $@ for arguments.'",
      "AGENT: '✓ Research complete! Let's write professional scripts.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Script Header and Strict Mode ---'",
      "Create tool: `cat > script-template.sh << 'EOF'`",
      "#!/bin/bash\n# Script: script-template.sh\n# Description: Template for robust bash scripts\n# Author: Your Name\n# Date: 2025-10-08\n\n# Strict mode - exit on error\nset -euo pipefail\n# -e: Exit on error\n# -u: Error on undefined variables\n# -o pipefail: Pipeline fails if any command fails\n\n# Script directory\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[0;33m'\nNC='\\033[0m' # No Color\n\n# Functions\nerror() {\n    echo -e \"${RED}ERROR: $*${NC}\" >&2\n}\n\nwarning() {\n    echo -e \"${YELLOW}WARNING: $*${NC}\" >&2\n}\n\ninfo() {\n    echo -e \"${GREEN}INFO: $*${NC}\"\n}\n\n# Main code here\ninfo \"Script started\"\nEOF",
      "Run command: `chmod +x script-template.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Functions for Reusability ---'",
      "Create tool: `cat > functions-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Function with return value\nget_timestamp() {\n    date +\"%Y-%m-%d %H:%M:%S\"\n}\n\n# Function with parameters\ngreet() {\n    local name=\"$1\"\n    local age=\"${2:-unknown}\"\n    echo \"Hello $name, age: $age\"\n}\n\n# Function with return code\ncheck_file() {\n    local file=\"$1\"\n    if [ -f \"$file\" ]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Usage\necho \"Current time: $(get_timestamp)\"\ngreet \"Alice\" \"30\"\ngreet \"Bob\"  # Age defaults to \"unknown\"\n\nif check_file \"/etc/passwd\"; then\n    echo \"/etc/passwd exists\"\nelse\n    echo \"/etc/passwd not found\"\nfi\nEOF",
      "Run command: `chmod +x functions-demo.sh`",
      "Run command: `./functions-demo.sh`",
      "AGENT: 'Current time: 2025-10-08 18:45:30'",
      "AGENT: 'Hello Alice, age: 30'",
      "AGENT: 'Hello Bob, age: unknown'",
      "AGENT: '/etc/passwd exists'",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Argument Parsing ---'",
      "Create tool: `cat > args-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Default values\nVERBOSE=false\nOUTPUT_FILE=\"\"\nINPUT_FILE=\"\"\n\n# Usage function\nusage() {\n    cat << EOF\nUsage: $0 [OPTIONS]\n\nOptions:\n    -i FILE     Input file (required)\n    -o FILE     Output file (required)\n    -v          Verbose mode\n    -h          Show this help\n\nExample:\n    $0 -i input.txt -o output.txt -v\nEOF\n    exit 1\n}\n\n# Parse options\nwhile getopts \"i:o:vh\" opt; do\n    case $opt in\n        i) INPUT_FILE=\"$OPTARG\" ;;\n        o) OUTPUT_FILE=\"$OPTARG\" ;;\n        v) VERBOSE=true ;;\n        h) usage ;;\n        *) usage ;;\n    esac\ndone\n\n# Validate required arguments\nif [ -z \"$INPUT_FILE\" ] || [ -z \"$OUTPUT_FILE\" ]; then\n    echo \"ERROR: -i and -o are required\" >&2\n    usage\nfi\n\n# Use arguments\nif [ \"$VERBOSE\" = true ]; then\n    echo \"Input: $INPUT_FILE\"\n    echo \"Output: $OUTPUT_FILE\"\n    echo \"Verbose: enabled\"\nfi\n\necho \"Processing $INPUT_FILE -> $OUTPUT_FILE\"\nEOF",
      "Run command: `chmod +x args-demo.sh`",
      "Run command: `./args-demo.sh -i input.txt -o output.txt -v`",
      "AGENT: 'Input: input.txt'",
      "AGENT: 'Output: output.txt'",
      "AGENT: 'Verbose: enabled'",
      "AGENT: 'Processing input.txt -> output.txt'",
      "AGENT: ''",
      "AGENT: '--- Approach 4: Error Handling with trap ---'",
      "Create tool: `cat > error-handling.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Cleanup function\ncleanup() {\n    local exit_code=$?\n    echo \"Cleaning up...\"\n    rm -f /tmp/temp_file_*\n    if [ $exit_code -ne 0 ]; then\n        echo \"Script failed with exit code: $exit_code\" >&2\n    fi\n}\n\n# Run cleanup on exit or error\ntrap cleanup EXIT\ntrap 'echo \"Error on line $LINENO\" >&2' ERR\n\n# Create temp file\nTEMP_FILE=\"/tmp/temp_file_$$\"\ntouch \"$TEMP_FILE\"\necho \"Created temp file: $TEMP_FILE\"\n\n# Simulate work\necho \"Doing work...\"\nsleep 1\n\n# Simulate error (comment out to test success)\n# false\n\necho \"Work completed\"\nEOF",
      "Run command: `chmod +x error-handling.sh`",
      "Run command: `./error-handling.sh`",
      "AGENT: 'Created temp file: /tmp/temp_file_12345'",
      "AGENT: 'Doing work...'",
      "AGENT: 'Work completed'",
      "AGENT: 'Cleaning up...'",
      "AGENT: ''",
      "AGENT: '--- Approach 5: Arrays and Loops ---'",
      "Create tool: `cat > arrays-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Indexed arrays\nfruits=(\"apple\" \"banana\" \"cherry\")\n\necho \"Fruits:\"\nfor fruit in \"${fruits[@]}\"; do\n    echo \"  - $fruit\"\ndone\n\necho \"Fruit count: ${#fruits[@]}\"\necho \"First fruit: ${fruits[0]}\"\n\n# Associative arrays (dictionaries)\ndeclare -A ages\nages[\"Alice\"]=30\nages[\"Bob\"]=25\nages[\"Charlie\"]=35\n\necho \"\"\necho \"Ages:\"\nfor name in \"${!ages[@]}\"; do\n    echo \"  $name is ${ages[$name]} years old\"\ndone\n\n# Loop over files\necho \"\"\necho \"Text files:\"\nfor file in *.txt; do\n    if [ -f \"$file\" ]; then\n        echo \"  Found: $file\"\n    fi\ndone\n\n# Loop with counter\necho \"\"\necho \"Countdown:\"\nfor i in {5..1}; do\n    echo \"  $i...\"\n    sleep 0.5\ndone\necho \"  Liftoff!\"\nEOF",
      "Run command: `chmod +x arrays-demo.sh`",
      "Run command: `./arrays-demo.sh`",
      "AGENT: 'Fruits:'",
      "AGENT: '  - apple'",
      "AGENT: '  - banana'",
      "AGENT: '  - cherry'",
      "AGENT: 'Fruit count: 3'",
      "AGENT: 'First fruit: apple'",
      "AGENT: ''",
      "AGENT: 'Ages:'",
      "AGENT: '  Alice is 30 years old'",
      "AGENT: '  Bob is 25 years old'",
      "AGENT: '  Charlie is 35 years old'",
      "AGENT: '...'",
      "AGENT: ''",
      "AGENT: '--- Approach 6: Conditionals and Tests ---'",
      "Create tool: `cat > conditionals-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\nFILE=\"/etc/passwd\"\nNUMBER=42\nSTRING=\"hello\"\n\n# File tests\nif [ -f \"$FILE\" ]; then\n    echo \"$FILE exists and is a regular file\"\nfi\n\nif [ -d \"/etc\" ]; then\n    echo \"/etc is a directory\"\nfi\n\nif [ -r \"$FILE\" ]; then\n    echo \"$FILE is readable\"\nfi\n\n# Numeric comparisons\nif [ \"$NUMBER\" -gt 40 ]; then\n    echo \"$NUMBER is greater than 40\"\nfi\n\nif [ \"$NUMBER\" -eq 42 ]; then\n    echo \"$NUMBER equals 42\"\nfi\n\n# String comparisons\nif [ \"$STRING\" = \"hello\" ]; then\n    echo \"String equals hello\"\nfi\n\nif [ -n \"$STRING\" ]; then\n    echo \"String is not empty\"\nfi\n\nif [ -z \"\" ]; then\n    echo \"Empty string\"\nfi\n\n# Logical operators\nif [ -f \"$FILE\" ] && [ -r \"$FILE\" ]; then\n    echo \"File exists AND is readable\"\nfi\n\nif [ \"$NUMBER\" -gt 40 ] || [ \"$NUMBER\" -lt 10 ]; then\n    echo \"Number is > 40 OR < 10\"\nfi\n\n# Modern [[ ]] syntax (bash-specific, more powerful)\nif [[ \"$STRING\" == hello* ]]; then\n    echo \"String starts with 'hello'\"\nfi\n\nif [[ $NUMBER -gt 40 && $NUMBER -lt 50 ]]; then\n    echo \"Number is between 40 and 50\"\nfi\nEOF",
      "Run command: `chmod +x conditionals-demo.sh`",
      "Run command: `./conditionals-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 7: Input Validation ---'",
      "Create tool: `cat > validation-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\nvalidate_file() {\n    local file=\"$1\"\n    \n    if [ ! -f \"$file\" ]; then\n        echo \"ERROR: File '$file' does not exist\" >&2\n        return 1\n    fi\n    \n    if [ ! -r \"$file\" ]; then\n        echo \"ERROR: File '$file' is not readable\" >&2\n        return 1\n    fi\n    \n    return 0\n}\n\nvalidate_number() {\n    local num=\"$1\"\n    \n    if ! [[ \"$num\" =~ ^[0-9]+$ ]]; then\n        echo \"ERROR: '$num' is not a valid number\" >&2\n        return 1\n    fi\n    \n    return 0\n}\n\nvalidate_email() {\n    local email=\"$1\"\n    \n    if ! [[ \"$email\" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ ]]; then\n        echo \"ERROR: '$email' is not a valid email\" >&2\n        return 1\n    fi\n    \n    return 0\n}\n\n# Test validations\nif validate_file \"/etc/passwd\"; then\n    echo \"✓ File validation passed\"\nfi\n\nif validate_number \"123\"; then\n    echo \"✓ Number validation passed\"\nfi\n\nif validate_email \"user@example.com\"; then\n    echo \"✓ Email validation passed\"\nfi\n\n# Test failures\nvalidate_file \"/nonexistent\" || echo \"Failed as expected\"\nvalidate_number \"abc\" || echo \"Failed as expected\"\nvalidate_email \"not-an-email\" || echo \"Failed as expected\"\nEOF",
      "Run command: `chmod +x validation-demo.sh`",
      "Run command: `./validation-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 8: Logging System ---'",
      "Create tool: `cat > logging-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Log file\nLOG_FILE=\"/tmp/script.log\"\n\n# Log levels\nLOG_LEVEL_DEBUG=0\nLOG_LEVEL_INFO=1\nLOG_LEVEL_WARN=2\nLOG_LEVEL_ERROR=3\n\n# Current log level\nCURRENT_LOG_LEVEL=$LOG_LEVEL_INFO\n\n# Logging functions\nlog() {\n    local level=$1\n    local level_name=$2\n    shift 2\n    local message=\"$*\"\n    \n    if [ $level -ge $CURRENT_LOG_LEVEL ]; then\n        local timestamp=$(date +\"%Y-%m-%d %H:%M:%S\")\n        echo \"[$timestamp] [$level_name] $message\" | tee -a \"$LOG_FILE\"\n    fi\n}\n\nlog_debug() {\n    log $LOG_LEVEL_DEBUG \"DEBUG\" \"$@\"\n}\n\nlog_info() {\n    log $LOG_LEVEL_INFO \"INFO\" \"$@\"\n}\n\nlog_warn() {\n    log $LOG_LEVEL_WARN \"WARN\" \"$@\"\n}\n\nlog_error() {\n    log $LOG_LEVEL_ERROR \"ERROR\" \"$@\"\n}\n\n# Usage\nlog_debug \"This won't show (below threshold)\"\nlog_info \"Script started\"\nlog_info \"Processing data\"\nlog_warn \"Disk space low\"\nlog_error \"Connection failed\"\nlog_info \"Script completed\"\n\necho \"\"\necho \"Log file: $LOG_FILE\"\ncat \"$LOG_FILE\"\nEOF",
      "Run command: `chmod +x logging-demo.sh`",
      "Run command: `./logging-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 9: Complete Professional Script ---'",
      "Create tool: `cat > backup-script.sh << 'EOF'`",
      "#!/bin/bash\n# Script: backup-script.sh\n# Description: Professional backup script with error handling\n# Usage: ./backup-script.sh -s /source/dir -d /dest/dir [-v]\n\nset -euo pipefail\n\n# Constants\nSCRIPT_NAME=$(basename \"$0\")\nLOG_FILE=\"/var/log/backup.log\"\nDATE=$(date +\"%Y%m%d_%H%M%S\")\n\n# Variables\nSOURCE_DIR=\"\"\nDEST_DIR=\"\"\nVERBOSE=false\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[0;33m'\nNC='\\033[0;33m'\n\n# Logging functions\nlog_info() {\n    local msg=\"[INFO] $(date +\"%Y-%m-%d %H:%M:%S\") $*\"\n    echo -e \"${GREEN}$msg${NC}\"\n    echo \"$msg\" >> \"$LOG_FILE\"\n}\n\nlog_error() {\n    local msg=\"[ERROR] $(date +\"%Y-%m-%d %H:%M:%S\") $*\"\n    echo -e \"${RED}$msg${NC}\" >&2\n    echo \"$msg\" >> \"$LOG_FILE\"\n}\n\nlog_warn() {\n    local msg=\"[WARN] $(date +\"%Y-%m-%d %H:%M:%S\") $*\"\n    echo -e \"${YELLOW}$msg${NC}\"\n    echo \"$msg\" >> \"$LOG_FILE\"\n}\n\n# Cleanup function\ncleanup() {\n    local exit_code=$?\n    if [ $exit_code -ne 0 ]; then\n        log_error \"Backup failed with exit code: $exit_code\"\n    else\n        log_info \"Backup completed successfully\"\n    fi\n}\n\ntrap cleanup EXIT\ntrap 'log_error \"Error on line $LINENO\"' ERR\n\n# Usage function\nusage() {\n    cat << EOF\nUsage: $SCRIPT_NAME [OPTIONS]\n\nOptions:\n    -s DIR      Source directory (required)\n    -d DIR      Destination directory (required)\n    -v          Verbose output\n    -h          Show this help\n\nExample:\n    $SCRIPT_NAME -s /var/www -d /backup -v\nEOF\n    exit 1\n}\n\n# Parse arguments\nwhile getopts \"s:d:vh\" opt; do\n    case $opt in\n        s) SOURCE_DIR=\"$OPTARG\" ;;\n        d) DEST_DIR=\"$OPTARG\" ;;\n        v) VERBOSE=true ;;\n        h) usage ;;\n        *) usage ;;\n    esac\ndone\n\n# Validate arguments\nif [ -z \"$SOURCE_DIR\" ] || [ -z \"$DEST_DIR\" ]; then\n    log_error \"Source and destination directories are required\"\n    usage\nfi\n\nif [ ! -d \"$SOURCE_DIR\" ]; then\n    log_error \"Source directory does not exist: $SOURCE_DIR\"\n    exit 1\nfi\n\n# Create destination if needed\nmkdir -p \"$DEST_DIR\"\n\n# Perform backup\nlog_info \"Starting backup: $SOURCE_DIR -> $DEST_DIR\"\n\nBACKUP_NAME=\"backup_${DATE}.tar.gz\"\nBACKUP_PATH=\"$DEST_DIR/$BACKUP_NAME\"\n\nif [ \"$VERBOSE\" = true ]; then\n    tar -czv -f \"$BACKUP_PATH\" -C \"$(dirname \"$SOURCE_DIR\")\" \"$(basename \"$SOURCE_DIR\")\" 2>&1 | tee -a \"$LOG_FILE\"\nelse\n    tar -cz -f \"$BACKUP_PATH\" -C \"$(dirname \"$SOURCE_DIR\")\" \"$(basename \"$SOURCE_DIR\")\" 2>&1 | tee -a \"$LOG_FILE\" > /dev/null\nfi\n\n# Verify backup\nif [ -f \"$BACKUP_PATH\" ]; then\n    SIZE=$(du -h \"$BACKUP_PATH\" | cut -f1)\n    log_info \"Backup created: $BACKUP_PATH ($SIZE)\"\nelse\n    log_error \"Backup file was not created\"\n    exit 1\nfi\n\n# Rotate old backups (keep last 7)\nlog_info \"Rotating old backups (keeping 7 most recent)\"\nls -t \"$DEST_DIR\"/backup_*.tar.gz 2>/dev/null | tail -n +8 | xargs -r rm -f\n\nlog_info \"Backup process complete\"\nEOF",
      "Run command: `chmod +x backup-script.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 10: Best Practices Summary ---'",
      "AGENT: ''",
      "AGENT: '✅ DO:'",
      "AGENT: '  • Use set -euo pipefail at start'",
      "AGENT: '  • Quote all variables: \"$var\" not $var'",
      "AGENT: '  • Use functions for reusability'",
      "AGENT: '  • Add usage/help function'",
      "AGENT: '  • Validate all inputs'",
      "AGENT: '  • Use trap for cleanup'",
      "AGENT: '  • Log important events'",
      "AGENT: '  • Use meaningful variable names'",
      "AGENT: '  • Add comments for complex logic'",
      "AGENT: '  • Use local variables in functions'",
      "AGENT: ''",
      "AGENT: '❌ DON\\'T:'",
      "AGENT: '  • Use unquoted variables'",
      "AGENT: '  • Ignore errors (check return codes)'",
      "AGENT: '  • Use global variables unnecessarily'",
      "AGENT: '  • Forget to validate inputs'",
      "AGENT: '  • Use eval (security risk)'",
      "AGENT: '  • Write long scripts without functions'",
      "AGENT: ''",
      "AGENT: '✓ SOLUTION SUMMARY:'",
      "AGENT: '  ✓ Used set -euo pipefail for strict error handling.'",
      "AGENT: '  ✓ Created reusable functions with local variables.'",
      "AGENT: '  ✓ Parsed command-line arguments with getopts.'",
      "AGENT: '  ✓ Implemented cleanup with trap EXIT.'",
      "AGENT: '  ✓ Used arrays and associative arrays.'",
      "AGENT: '  ✓ Performed proper input validation.'",
      "AGENT: '  ✓ Implemented leveled logging system.'",
      "AGENT: '  ✓ Created professional backup script with all best practices.'",
      "AGENT: '  ✓ Learned when to use [ ] vs [[ ]] conditionals.'",
      "AGENT: '  ✓ You now write professional, robust bash scripts! 🚀'"
    ],
    "commands": ["bash", "sh", "test", "trap", "getopts"],
    "packages": {
      "debian_ubuntu": ["bash"],
      "arch": ["bash"]
    },
    "related_commands": ["shellcheck", "shfmt"],
    "complexity": "advanced",
    "tags": ["bash", "scripting", "automation", "functions", "error-handling", "argument-parsing", "arrays", "best-practices", "trap"]
  }
]
