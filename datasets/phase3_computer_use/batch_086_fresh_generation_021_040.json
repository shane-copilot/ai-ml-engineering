[
  {
    "id": "scenario_lvm_expand_filesystem_086",
    "command": "lvextend",
    "scenario": "Expand a logical volume and resize the filesystem to use the new space.",
    "problem": "A server's root partition is running out of space. The underlying volume group has free space available, but the user doesn't know how to safely extend the logical volume and grow the filesystem without data loss.",
    "solution": "Use LVM commands to extend the logical volume with available free space, then use filesystem-specific tools (resize2fs for ext4, xfs_growfs for XFS) to expand the filesystem to use the newly allocated space. All operations can be done online without unmounting.",
    "steps": [
      "USER SAYS: 'My root filesystem is at 95% capacity and I'm getting low disk space warnings. I'm using LVM and I can see there's free space in the volume group. How do I safely expand it?'",
      "AGENT: 'Good news! With LVM, you can expand the volume and filesystem online without any downtime. Let me research the exact procedure for your filesystem type.'",
      "AGENT: ''",
      "AGENT: 'üîç RESEARCH PHASE: LVM volume expansion...'",
      "AGENT: '[Searching] \"lvm extend logical volume and resize filesystem\"'",
      "AGENT: '[Found] The process is: 1) Extend the logical volume with `lvextend`, 2) Grow the filesystem with the appropriate tool for your filesystem type.'",
      "AGENT: '[Found] For ext4: use `resize2fs`. For XFS: use `xfs_growfs`. Both can be done while the filesystem is mounted.'",
      "AGENT: '[Found] You can use `lvextend -r` to automatically resize the filesystem after extending the volume.'",
      "AGENT: '‚úì Research complete! Let's identify your setup and expand it safely.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Identify Current State ---'",
      "Run command: `df -h /`",
      "AGENT: 'Filesystem                  Size  Used Avail Use% Mounted on'",
      "AGENT: '/dev/mapper/vg0-root         20G   19G  512M  95% /'",
      "AGENT: 'The root filesystem is indeed at 95% capacity.'",
      "AGENT: ''",
      "Run command: `lvdisplay /dev/vg0/root`",
      "AGENT: '  --- Logical volume ---'",
      "AGENT: '  LV Path                /dev/vg0/root'",
      "AGENT: '  LV Name                root'",
      "AGENT: '  VG Name                vg0'",
      "AGENT: '  LV Size                20.00 GiB'",
      "AGENT: ''",
      "Run command: `vgdisplay vg0`",
      "AGENT: '  --- Volume group ---'",
      "AGENT: '  VG Name               vg0'",
      "AGENT: '  VG Size               100.00 GiB'",
      "AGENT: '  Alloc PE / Size       5120 / 20.00 GiB'",
      "AGENT: '  Free  PE / Size       20480 / 80.00 GiB'",
      "AGENT: 'üí° Perfect! We have 80 GiB of free space in the volume group.'",
      "AGENT: ''",
      "Run command: `mount | grep ' / '`",
      "AGENT: '/dev/mapper/vg0-root on / type ext4 (rw,relatime)'",
      "AGENT: 'The filesystem type is ext4, so we'll use `resize2fs` after extending.'",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Extend the Logical Volume ---'",
      "AGENT: 'Let's add 30 GB to the root volume. We can use `-L +30G` to add 30 GB, or `-l +100%FREE` to use all available space.'",
      "Run command: `sudo lvextend -L +30G /dev/vg0/root`",
      "AGENT: '  Size of logical volume vg0/root changed from 20.00 GiB to 50.00 GiB.'",
      "AGENT: '  Logical volume vg0/root successfully resized.'",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Resize the Filesystem ---'",
      "AGENT: 'Now we need to tell the ext4 filesystem to expand into the new space. This can be done while the filesystem is mounted.'",
      "Run command: `sudo resize2fs /dev/vg0/root`",
      "AGENT: 'resize2fs 1.47.0 (5-Feb-2023)'",
      "AGENT: 'Filesystem at /dev/vg0/root is mounted on /; on-line resizing required'",
      "AGENT: 'old_desc_blocks = 3, new_desc_blocks = 7'",
      "AGENT: 'The filesystem on /dev/vg0/root is now 13107200 (4k) blocks long.'",
      "AGENT: ''",
      "AGENT: '--- Approach 4: Verify the Expansion ---'",
      "Run command: `df -h /`",
      "AGENT: 'Filesystem                  Size  Used Avail Use% Mounted on'",
      "AGENT: '/dev/mapper/vg0-root         50G   19G   29G  40% /'",
      "AGENT: '‚úì Success! The filesystem went from 20 GB to 50 GB and is now at 40% usage.'",
      "AGENT: ''",
      "AGENT: '--- Alternative: One-Command Approach ---'",
      "AGENT: 'Modern LVM versions support the `-r` flag to automatically resize the filesystem:'",
      "AGENT: '`sudo lvextend -L +30G -r /dev/vg0/root`'",
      "AGENT: 'This would have done both steps in one command. The `-r` flag calls `resize2fs` or `xfs_growfs` automatically.'",
      "AGENT: ''",
      "AGENT: '--- XFS Note ---'",
      "AGENT: 'If your filesystem was XFS instead of ext4, you would use:'",
      "AGENT: '`sudo xfs_growfs /` (note: you specify the mount point, not the device)'",
      "AGENT: ''",
      "AGENT: '‚úì SOLUTION SUMMARY:'",
      "AGENT: '  ‚úì Identified the logical volume, volume group, and filesystem type.'",
      "AGENT: '  ‚úì Verified there was sufficient free space in the volume group.'",
      "AGENT: '  ‚úì Extended the logical volume by 30 GB using `lvextend`.'",
      "AGENT: '  ‚úì Resized the ext4 filesystem online using `resize2fs`.'",
      "AGENT: '  ‚úì Confirmed the filesystem now shows 50 GB with plenty of free space.'",
      "AGENT: '  ‚úì All operations were performed online without unmounting or downtime! üì¶'"
    ],
    "commands": ["df", "lvdisplay", "vgdisplay", "mount", "lvextend", "resize2fs", "xfs_growfs"],
    "packages": {
      "debian_ubuntu": ["lvm2", "e2fsprogs", "xfsprogs"],
      "arch": ["lvm2", "e2fsprogs", "xfsprogs"]
    },
    "related_commands": ["pvdisplay", "vgextend", "lvcreate", "fdisk"],
    "complexity": "intermediate",
    "tags": ["lvm", "filesystem", "disk-management", "storage", "ext4", "xfs", "resize", "sysadmin"]
  },
  {
    "id": "scenario_tcpdump_capture_http_087",
    "command": "tcpdump",
    "scenario": "Capture and analyze HTTP traffic to debug API communication issues.",
    "problem": "A developer's application is making HTTP requests to an API, but they're getting unexpected responses. They need to see the exact request headers and response codes being sent over the network to determine if the problem is in their application or the API.",
    "solution": "Use tcpdump to capture packets on the network interface, filter for HTTP traffic on port 80, save to a file, and then analyze the capture with tcpdump or Wireshark. Demonstrate how to read ASCII content directly from tcpdump output.",
    "steps": [
      "USER SAYS: 'My app is calling an API at api.example.com and getting 403 Forbidden errors, but the same request works in Postman. I need to see what headers my application is actually sending.'",
      "AGENT: 'This is a perfect use case for packet capture. We'll use tcpdump to capture the raw HTTP traffic and see exactly what's being sent and received. Let me research the best approach.'",
      "AGENT: ''",
      "AGENT: 'üîç RESEARCH PHASE: Capturing HTTP traffic with tcpdump...'",
      "AGENT: '[Searching] \"tcpdump capture http requests\"'",
      "AGENT: '[Found] tcpdump requires root privileges to capture packets.'",
      "AGENT: '[Found] The `-i` flag specifies the network interface. Use `any` to capture on all interfaces.'",
      "AGENT: '[Found] The `-A` flag prints packet contents in ASCII, making HTTP requests readable.'",
      "AGENT: '[Found] Filter expressions can limit capture to specific ports: `port 80` for HTTP, `port 443` for HTTPS.'",
      "AGENT: '[Found] For HTTPS, you can only see the TLS handshake, not the encrypted payload. You'd need to decrypt with the private key or use application-level logging.'",
      "AGENT: '‚úì Research complete! Let's capture and analyze your HTTP traffic.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Identify the Network Interface ---'",
      "Run command: `ip addr show`",
      "AGENT: '1: lo: <LOOPBACK,UP,LOWER_UP> ...'",
      "AGENT: '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> inet 192.168.1.100/24'",
      "AGENT: '3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> ...'",
      "AGENT: 'Our main interface is `eth0`. We can also use `any` to capture on all interfaces.'",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Start a Live Capture ---'",
      "AGENT: 'Let's capture HTTP traffic (port 80) and display it in real-time. Run this, then trigger your application.'",
      "Run command: `sudo tcpdump -i any -A 'tcp port 80 and (host api.example.com or dst api.example.com)'`",
      "AGENT: 'tcpdump: data link type LINUX_SLL2'",
      "AGENT: 'tcpdump: verbose output suppressed, use -v[v]... for full protocol decode'",
      "AGENT: 'listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes'",
      "AGENT: ''",
      "AGENT: 'Now, in another terminal, run your application to make the API call...'",
      "AGENT: ''",
      "AGENT: '--- Captured Packet Output ---'",
      "AGENT: '21:30:15.123456 IP 192.168.1.100.54321 > api.example.com.http: Flags [P.], seq 1:234, ack 1, win 502, length 233'",
      "AGENT: 'GET /api/v1/users HTTP/1.1'",
      "AGENT: 'Host: api.example.com'",
      "AGENT: 'User-Agent: MyApp/1.0'",
      "AGENT: 'Accept: */*'",
      "AGENT: ''",
      "AGENT: '21:30:15.234567 IP api.example.com.http > 192.168.1.100.54321: Flags [P.], seq 1:189, ack 234, win 502, length 188'",
      "AGENT: 'HTTP/1.1 403 Forbidden'",
      "AGENT: 'Server: nginx/1.18.0'",
      "AGENT: 'Content-Type: text/html'",
      "AGENT: 'Content-Length: 162'",
      "AGENT: ''",
      "AGENT: '<html>'",
      "AGENT: '<head><title>403 Forbidden</title></head>'",
      "AGENT: '<body>Missing required header: Authorization</body>'",
      "AGENT: '</html>'",
      "AGENT: ''",
      "AGENT: 'üí° AHA! The problem is clear: Your application is NOT sending the Authorization header that the API requires! Your Postman request probably has it configured, but your application code forgot to include it.'",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Save Capture to File for Later Analysis ---'",
      "AGENT: 'If you want to save the capture and analyze it later (possibly with Wireshark), use the `-w` flag:'",
      "Run command: `sudo tcpdump -i any 'tcp port 80 and host api.example.com' -w /tmp/api_debug.pcap`",
      "AGENT: 'tcpdump: listening on any, link-type LINUX_SLL2, snapshot length 262144 bytes'",
      "AGENT: '(Run your application...)'",
      "AGENT: '^C15 packets captured'",
      "AGENT: ''",
      "AGENT: 'Now you can read it back:'",
      "Run command: `tcpdump -A -r /tmp/api_debug.pcap`",
      "AGENT: 'Or open it in Wireshark for a GUI analysis:'",
      "Run command: `wireshark /tmp/api_debug.pcap &`",
      "AGENT: ''",
      "AGENT: '--- Approach 4: More Advanced Filtering ---'",
      "AGENT: 'Capture only POST requests:'",
      "AGENT: '`sudo tcpdump -i any -A \"tcp port 80 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)\"`'",
      "AGENT: '(This looks for the ASCII bytes \"POST\" in the packet)'",
      "AGENT: ''",
      "AGENT: 'Capture with more verbose output:'",
      "AGENT: '`sudo tcpdump -i any -vvv -A port 80`'",
      "AGENT: ''",
      "AGENT: '--- Important Note: HTTPS ---'",
      "AGENT: 'If the API uses HTTPS (port 443), the payload is encrypted. tcpdump will only show you the TLS handshake, not the actual HTTP headers. In that case, you need to:'",
      "AGENT: '1. Use application-level logging in your code.'",
      "AGENT: '2. Use a debugging proxy like mitmproxy that can decrypt HTTPS.'",
      "AGENT: '3. Configure your application to trust a custom CA certificate for interception.'",
      "AGENT: ''",
      "AGENT: '‚úì SOLUTION SUMMARY:'",
      "AGENT: '  ‚úì Identified the network interface to capture on.'",
      "AGENT: '  ‚úì Used tcpdump with `-A` flag to capture and display HTTP traffic in ASCII.'",
      "AGENT: '  ‚úì Applied filter expressions to only capture traffic to/from the specific API host on port 80.'",
      "AGENT: '  ‚úì Successfully identified the missing Authorization header by examining the raw request.'",
      "AGENT: '  ‚úì Demonstrated how to save captures to a file for later analysis.'",
      "AGENT: '  ‚úì You now have a powerful technique for debugging network-level application issues! üîç'"
    ],
    "commands": ["tcpdump", "ip", "wireshark"],
    "packages": {
      "debian_ubuntu": ["tcpdump", "iproute2", "wireshark"],
      "arch": ["tcpdump", "iproute2", "wireshark-qt"]
    },
    "related_commands": ["tshark", "ngrep", "mitmproxy", "curl"],
    "complexity": "intermediate",
    "tags": ["tcpdump", "network", "debugging", "http", "packet-capture", "wireshark", "troubleshooting", "api"]
  }
]
