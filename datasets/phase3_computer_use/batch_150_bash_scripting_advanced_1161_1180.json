[
  {
    "id": "scenario_bash_scripting_advanced_148",
    "command": "bash",
    "scenario": "Master advanced Bash scripting techniques for robust automation and system administration.",
    "problem": "Need to write maintainable scripts with error handling, parse arguments, use functions, handle signals, implement logging, create interactive menus, validate input, and follow best practices for production-ready bash scripts.",
    "solution": "Learn advanced bash features: functions, arrays, associative arrays, error trapping, argument parsing, here documents, process substitution, parameter expansion, shell options (set -euo pipefail), and proper script structure.",
    "steps": [
      "USER SAYS: 'How do I write professional, robust bash scripts with proper error handling and best practices?'",
      "AGENT: 'Let me show you advanced bash scripting! We'll cover functions, error handling, argument parsing, and production-ready patterns.'",
      "AGENT: ''",
      "AGENT: 'ðŸ” RESEARCH PHASE: Advanced bash scripting...'",
      "AGENT: '[Searching] \"bash scripting best practices error handling functions\"'",
      "AGENT: '[Found] set -euo pipefail for strict error handling.'",
      "AGENT: '[Found] Functions for code reuse, arrays for data structures.'",
      "AGENT: '[Found] trap for signal handling, proper logging practices.'",
      "AGENT: '[Found] getopts for argument parsing, parameter expansion tricks.'",
      "AGENT: 'âœ“ Research complete! Let's master advanced bash.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Script Template with Best Practices ---'",
      "Create tool: `cat > script-template.sh << 'EOF'`",
      "#!/bin/bash\n# Script: script-template.sh\n# Description: Professional bash script template\n# Author: Your Name\n# Date: 2025-10-08\n\n# Strict error handling\nset -euo pipefail\n\n# Global variables\nreadonly SCRIPT_NAME=\"$(basename \"${BASH_SOURCE[0]}\")\"\nreadonly SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nLOG_FILE=\"${SCRIPT_DIR}/${SCRIPT_NAME%.sh}.log\"\nVERBOSE=0\n\n# Colors for output\nreadonly RED='\\033[0;31m'\nreadonly GREEN='\\033[0;32m'\nreadonly YELLOW='\\033[1;33m'\nreadonly NC='\\033[0m' # No Color\n\n# Logging functions\nlog() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\nerror() {\n    echo \"${RED}[ERROR]${NC} $*\" >&2\n    log \"ERROR: $*\"\n}\n\nwarn() {\n    echo \"${YELLOW}[WARN]${NC} $*\" >&2\n    log \"WARN: $*\"\n}\n\ninfo() {\n    echo \"${GREEN}[INFO]${NC} $*\"\n    log \"INFO: $*\"\n}\n\ndebug() {\n    if [ \"$VERBOSE\" -eq 1 ]; then\n        echo \"[DEBUG] $*\"\n        log \"DEBUG: $*\"\n    fi\n}\n\n# Cleanup on exit\ncleanup() {\n    debug \"Cleanup function called\"\n    # Add cleanup tasks here\n}\n\ntrap cleanup EXIT\n\n# Usage information\nusage() {\n    cat << USAGE\nUsage: $SCRIPT_NAME [OPTIONS] <argument>\n\nDescription:\n    Professional bash script template with best practices.\n\nOptions:\n    -h, --help       Show this help message\n    -v, --verbose    Enable verbose output\n    -o, --output FILE  Output file (default: output.txt)\n\nExamples:\n    $SCRIPT_NAME input.txt\n    $SCRIPT_NAME -v -o result.txt input.txt\nUSAGE\n    exit 1\n}\n\n# Main function\nmain() {\n    info \"Script started\"\n    \n    # Your script logic here\n    \n    info \"Script completed successfully\"\n}\n\n# Parse arguments\nOUTPUT_FILE=\"output.txt\"\n\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        -h|--help)\n            usage\n            ;;\n        -v|--verbose)\n            VERBOSE=1\n            shift\n            ;;\n        -o|--output)\n            OUTPUT_FILE=\"$2\"\n            shift 2\n            ;;\n        -*)\n            error \"Unknown option: $1\"\n            usage\n            ;;\n        *)\n            INPUT_FILE=\"$1\"\n            shift\n            ;;\n    esac\ndone\n\n# Validate required arguments\nif [ -z \"${INPUT_FILE:-}\" ]; then\n    error \"Missing required argument: input file\"\n    usage\nfi\n\n# Run main function\nmain\nEOF",
      "Run command: `chmod +x script-template.sh`",
      "Run command: `./script-template.sh -h`",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Functions ---'",
      "Create tool: `cat > functions-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Simple function\ngreet() {\n    echo \"Hello, $1!\"\n}\n\n# Function with return value\nadd() {\n    local result=$(( $1 + $2 ))\n    echo \"$result\"\n}\n\n# Function with return code\ncheck_file() {\n    if [ -f \"$1\" ]; then\n        echo \"File exists: $1\"\n        return 0\n    else\n        echo \"File not found: $1\" >&2\n        return 1\n    fi\n}\n\n# Function with local variables\nprocess_data() {\n    local input=\"$1\"\n    local output=\"${input}.processed\"\n    \n    echo \"Processing: $input\"\n    echo \"Output: $output\"\n    \n    # Return via echo\n    echo \"$output\"\n}\n\n# Usage\ngreet \"World\"\n\nsum=$(add 5 3)\necho \"Sum: $sum\"\n\nif check_file \"test.txt\"; then\n    echo \"Check passed\"\nelse\n    echo \"Check failed\"\nfi\n\nresult=$(process_data \"data.txt\")\necho \"Result: $result\"\nEOF",
      "Run command: `chmod +x functions-demo.sh && ./functions-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Arrays ---'",
      "Create tool: `cat > arrays-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Indexed array\nfruits=(\"apple\" \"banana\" \"orange\")\n\necho \"First fruit: ${fruits[0]}\"\necho \"All fruits: ${fruits[@]}\"\necho \"Number of fruits: ${#fruits[@]}\"\n\n# Add element\nfruits+=(\"grape\")\n\n# Loop through array\nfor fruit in \"${fruits[@]}\"; do\n    echo \"Fruit: $fruit\"\ndone\n\n# Loop with index\nfor i in \"${!fruits[@]}\"; do\n    echo \"Index $i: ${fruits[$i]}\"\ndone\n\n# Associative array (dictionary)\ndeclare -A colors\ncolors[red]=\"#FF0000\"\ncolors[green]=\"#00FF00\"\ncolors[blue]=\"#0000FF\"\n\necho \"Red: ${colors[red]}\"\n\n# Loop through associative array\nfor key in \"${!colors[@]}\"; do\n    echo \"$key: ${colors[$key]}\"\ndone\n\n# Array from command output\nreadarray -t files < <(ls *.txt 2>/dev/null || true)\necho \"Found ${#files[@]} txt files\"\nEOF",
      "Run command: `chmod +x arrays-demo.sh && ./arrays-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 4: Error Handling ---'",
      "Create tool: `cat > error-handling.sh << 'EOF'`",
      "#!/bin/bash\n\n# Strict mode\nset -euo pipefail\n\n# Error handler\nerror_handler() {\n    local line=$1\n    local command=\"$2\"\n    echo \"Error on line $line: $command\" >&2\n    exit 1\n}\n\ntrap 'error_handler ${LINENO} \"$BASH_COMMAND\"' ERR\n\n# Check command success\nif ! command -v docker &> /dev/null; then\n    echo \"Docker not installed\" >&2\n    exit 1\nfi\n\n# Try-catch equivalent\nif ! result=$(dangerous_command 2>&1); then\n    echo \"Command failed: $result\" >&2\n    # Handle error\nfi\n\n# Ensure cleanup on exit\ncleanup() {\n    echo \"Cleaning up...\"\n    rm -f /tmp/tempfile\n}\ntrap cleanup EXIT\n\n# Create temp file\ntouch /tmp/tempfile\n\necho \"Script completed\"\nEOF",
      "AGENT: ''",
      "AGENT: '--- Approach 5: Argument Parsing with getopts ---'",
      "Create tool: `cat > getopts-demo.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\nVERBOSE=0\nOUTPUT_FILE=\"\"\nINPUT_FILE=\"\"\n\nusage() {\n    cat << EOF\nUsage: $(basename \"$0\") [-v] [-o output] -i input\n\nOptions:\n    -v          Verbose mode\n    -o FILE     Output file\n    -i FILE     Input file (required)\n    -h          Show this help\nEOF\n    exit 1\n}\n\nwhile getopts \"vo:i:h\" opt; do\n    case $opt in\n        v)\n            VERBOSE=1\n            ;;\n        o)\n            OUTPUT_FILE=\"$OPTARG\"\n            ;;\n        i)\n            INPUT_FILE=\"$OPTARG\"\n            ;;\n        h)\n            usage\n            ;;\n        \\?)\n            echo \"Invalid option: -$OPTARG\" >&2\n            usage\n            ;;\n        :)\n            echo \"Option -$OPTARG requires an argument\" >&2\n            usage\n            ;;\n    esac\ndone\n\nshift $((OPTIND-1))\n\n# Validate required arguments\nif [ -z \"$INPUT_FILE\" ]; then\n    echo \"Error: -i option is required\" >&2\n    usage\nfi\n\necho \"Verbose: $VERBOSE\"\necho \"Input: $INPUT_FILE\"\necho \"Output: ${OUTPUT_FILE:-default.txt}\"\nEOF",
      "Run command: `chmod +x getopts-demo.sh`",
      "Run command: `./getopts-demo.sh -v -i input.txt -o output.txt`",
      "AGENT: ''",
      "AGENT: '--- Approach 6: Parameter Expansion ---'",
      "Create tool: `cat > param-expansion.sh << 'EOF'`",
      "#!/bin/bash\n\nFILE=\"/path/to/file.txt\"\n\n# Remove path (get filename)\necho \"Filename: ${FILE##*/}\"\n# Output: file.txt\n\n# Remove extension\necho \"No extension: ${FILE%.txt}\"\n# Output: /path/to/file\n\n# Get directory\necho \"Directory: ${FILE%/*}\"\n# Output: /path/to\n\n# Get extension\necho \"Extension: ${FILE##*.}\"\n# Output: txt\n\n# Default value if unset\necho \"Value: ${UNDEFINED_VAR:-default}\"\n# Output: default\n\n# String substitution\nTEXT=\"hello world\"\necho \"${TEXT/world/universe}\"\n# Output: hello universe\n\n# String length\necho \"Length: ${#TEXT}\"\n# Output: 11\n\n# Substring\necho \"Substring: ${TEXT:0:5}\"\n# Output: hello\n\n# Uppercase/lowercase\necho \"Upper: ${TEXT^^}\"\necho \"Lower: ${TEXT,,}\"\nEOF",
      "Run command: `bash param-expansion.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 7: Interactive Menus ---'",
      "Create tool: `cat > menu.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\nmenu() {\n    clear\n    echo \"=======================\"\n    echo \"   Main Menu\"\n    echo \"=======================\"\n    echo \"1. List files\"\n    echo \"2. Show disk usage\"\n    echo \"3. Check memory\"\n    echo \"4. Exit\"\n    echo \"=======================\"\n    read -p \"Enter choice [1-4]: \" choice\n    \n    case $choice in\n        1)\n            ls -lh\n            ;;\n        2)\n            df -h\n            ;;\n        3)\n            free -h\n            ;;\n        4)\n            echo \"Goodbye!\"\n            exit 0\n            ;;\n        *)\n            echo \"Invalid choice\"\n            ;;\n    esac\n    \n    read -p \"Press Enter to continue...\"\n    menu  # Recursive call\n}\n\n# Start menu\nmenu\nEOF",
      "Run command: `chmod +x menu.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 8: Input Validation ---'",
      "Create tool: `cat > validation.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Validate number\nvalidate_number() {\n    if [[ ! $1 =~ ^[0-9]+$ ]]; then\n        echo \"Error: Not a number\" >&2\n        return 1\n    fi\n    return 0\n}\n\n# Validate email\nvalidate_email() {\n    if [[ ! $1 =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ ]]; then\n        echo \"Error: Invalid email\" >&2\n        return 1\n    fi\n    return 0\n}\n\n# Validate file exists\nvalidate_file() {\n    if [ ! -f \"$1\" ]; then\n        echo \"Error: File not found: $1\" >&2\n        return 1\n    fi\n    return 0\n}\n\n# Validate IP address\nvalidate_ip() {\n    if [[ ! $1 =~ ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$ ]]; then\n        echo \"Error: Invalid IP address\" >&2\n        return 1\n    fi\n    return 0\n}\n\n# Interactive input with validation\nread -p \"Enter age: \" age\nif validate_number \"$age\"; then\n    echo \"Valid age: $age\"\nfi\n\nread -p \"Enter email: \" email\nif validate_email \"$email\"; then\n    echo \"Valid email: $email\"\nfi\nEOF",
      "AGENT: ''",
      "AGENT: '--- Approach 9: Here Documents ---'",
      "Create tool: `cat > heredoc-demo.sh << 'EOF'`",
      "#!/bin/bash\n\n# Multi-line string\ncat << 'HEREDOC'\nThis is a multi-line\nstring using here document.\nVariables are NOT expanded.\nHEREDOC\n\n# With variable expansion\nNAME=\"World\"\ncat << HEREDOC\nHello, $NAME!\nCurrent dir: $(pwd)\nHEREDOC\n\n# Write to file\ncat > config.txt << 'EOF'\n# Configuration file\nhost=localhost\nport=8080\nEOF\n\necho \"Config file created\"\n\n# Indented here document\nif true; then\n    cat <<- EOF\n\t\tIndented text\n\t\tTabs are stripped\n\tEOF\nfi\nEOF",
      "Run command: `bash heredoc-demo.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 10: Process Substitution ---'",
      "Create tool: `cat > process-sub.sh << 'EOF'`",
      "#!/bin/bash\n\n# Compare two command outputs\ndiff <(ls /tmp) <(ls /var/tmp)\n\n# Read from command output\nwhile read -r line; do\n    echo \"Line: $line\"\ndone < <(ls *.txt)\n\n# Use as input to command\ngrep \"error\" <(journalctl -n 100)\n\n# Multiple inputs\npaste <(seq 1 5) <(seq 6 10)\nEOF",
      "AGENT: ''",
      "AGENT: '--- Bonus: Production-Ready Script Example ---'",
      "Create tool: `cat > backup-script.sh << 'EOF'`",
      "#!/bin/bash\n# Backup script with logging and error handling\n\nset -euo pipefail\n\n# Configuration\nreadonly SCRIPT_NAME=\"$(basename \"$0\")\"\nreadonly BACKUP_DIR=\"/backup\"\nreadonly LOG_FILE=\"/var/log/${SCRIPT_NAME%.sh}.log\"\nreadonly MAX_BACKUPS=7\n\n# Logging\nlog() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\nerror_exit() {\n    log \"ERROR: $*\"\n    exit 1\n}\n\n# Cleanup on exit\ncleanup() {\n    log \"Cleanup complete\"\n}\ntrap cleanup EXIT\n\n# Backup function\ndo_backup() {\n    local source=\"$1\"\n    local timestamp=$(date +\"%Y%m%d_%H%M%S\")\n    local backup_file=\"${BACKUP_DIR}/backup_${timestamp}.tar.gz\"\n    \n    log \"Starting backup of $source\"\n    \n    if ! tar -czf \"$backup_file\" \"$source\" 2>> \"$LOG_FILE\"; then\n        error_exit \"Backup failed\"\n    fi\n    \n    log \"Backup created: $backup_file\"\n    echo \"$backup_file\"\n}\n\n# Rotate old backups\nrotate_backups() {\n    log \"Rotating old backups (keeping $MAX_BACKUPS)\"\n    \n    cd \"$BACKUP_DIR\" || error_exit \"Cannot access $BACKUP_DIR\"\n    \n    # Keep only MAX_BACKUPS most recent\n    ls -t backup_*.tar.gz 2>/dev/null | tail -n +$((MAX_BACKUPS + 1)) | xargs -r rm -f\n    \n    log \"Rotation complete\"\n}\n\n# Main\nmain() {\n    log \"===== Backup started =====\"\n    \n    # Check if backup directory exists\n    [ -d \"$BACKUP_DIR\" ] || mkdir -p \"$BACKUP_DIR\"\n    \n    # Perform backup\n    backup_file=$(do_backup \"/home/user/data\")\n    \n    # Rotate old backups\n    rotate_backups\n    \n    # Calculate size\n    local size=$(du -h \"$backup_file\" | cut -f1)\n    log \"Backup size: $size\"\n    \n    log \"===== Backup completed =====\"\n}\n\nmain \"$@\"\nEOF",
      "Run command: `chmod +x backup-script.sh`",
      "AGENT: ''",
      "AGENT: '--- Bonus: Best Practices Summary ---'",
      "AGENT: ''",
      "AGENT: '1. Always use strict mode:'",
      "AGENT: '   set -euo pipefail'",
      "AGENT: ''",
      "AGENT: '2. Quote variables:'",
      "AGENT: '   \"$variable\" not $variable'",
      "AGENT: ''",
      "AGENT: '3. Use readonly for constants:'",
      "AGENT: '   readonly MAX_RETRIES=3'",
      "AGENT: ''",
      "AGENT: '4. Use local in functions:'",
      "AGENT: '   local result=\"value\"'",
      "AGENT: ''",
      "AGENT: '5. Check command existence:'",
      "AGENT: '   command -v docker &> /dev/null || exit 1'",
      "AGENT: ''",
      "AGENT: '6. Use [[ ]] over [ ]:'",
      "AGENT: '   [[ $var == \"value\" ]]'",
      "AGENT: ''",
      "AGENT: '7. Handle cleanup:'",
      "AGENT: '   trap cleanup EXIT'",
      "AGENT: ''",
      "AGENT: '8. Use shellcheck:'",
      "AGENT: '   shellcheck script.sh'",
      "AGENT: ''",
      "AGENT: 'âœ“ SOLUTION SUMMARY:'",
      "AGENT: '  âœ“ Created professional script template with best practices.'",
      "AGENT: '  âœ“ Used functions for code organization and reuse.'",
      "AGENT: '  âœ“ Implemented arrays and associative arrays.'",
      "AGENT: '  âœ“ Added robust error handling with set -euo pipefail.'",
      "AGENT: '  âœ“ Parsed arguments with getopts.'",
      "AGENT: '  âœ“ Mastered parameter expansion tricks.'",
      "AGENT: '  âœ“ Created interactive menus for user interaction.'",
      "AGENT: '  âœ“ Validated user input with regex patterns.'",
      "AGENT: '  âœ“ Used here documents for multi-line content.'",
      "AGENT: '  âœ“ You now master advanced bash scripting! ðŸš€'"
    ],
    "commands": ["bash", "sh"],
    "packages": {
      "debian_ubuntu": ["bash", "shellcheck"],
      "arch": ["bash", "shellcheck"]
    },
    "related_commands": ["sh", "zsh", "fish"],
    "complexity": "advanced",
    "tags": ["bash", "scripting", "shell-scripting", "functions", "error-handling", "arrays", "argument-parsing", "automation", "best-practices"]
  }
]
