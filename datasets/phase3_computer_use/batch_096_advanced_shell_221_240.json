[
  {
    "id": "scenario_bash_advanced_functions_099",
    "command": "bash",
    "scenario": "Create reusable bash functions library for common sysadmin tasks with error handling.",
    "problem": "A sysadmin writes the same code patterns repeatedly in different scripts (checking if service is running, validating input, logging). They want to create a reusable library of bash functions they can source in any script.",
    "solution": "Create a bash library file with well-designed functions that include parameter validation, error handling, logging, and return codes. Demonstrate sourcing and using the library in various scripts.",
    "steps": [
      "USER SAYS: 'I keep writing the same bash code over and over - checking services, validating files exist, logging messages. How can I make this reusable?'",
      "AGENT: 'You can create a bash function library! It's a file of reusable functions that you source into any script. Let me show you how to build a professional sysadmin library with proper error handling.'",
      "AGENT: ''",
      "AGENT: 'ðŸ” RESEARCH PHASE: Bash function libraries and best practices...'",
      "AGENT: '[Searching] \"bash function library best practices error handling\"'",
      "AGENT: '[Found] Use `source` or `.` to load library into scripts.'",
      "AGENT: '[Found] Functions should validate parameters and return proper exit codes (0=success, non-zero=failure).'",
      "AGENT: '[Found] Use `set -euo pipefail` for strict error handling.'",
      "AGENT: '[Found] Prefix library function names to avoid conflicts (e.g., lib_function_name).'",
      "AGENT: 'âœ“ Research complete! Let's build a production-quality library.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Create the Function Library ---'",
      "Create tool: `cat > /usr/local/lib/sysadmin_lib.sh << 'EOF'`",
      "#!/bin/bash\n# Sysadmin Function Library\n# Source this file: source /usr/local/lib/sysadmin_lib.sh\n\nset -euo pipefail\n\n# Colors for output\nreadonly RED='\\033[0;31m'\nreadonly GREEN='\\033[0;32m'\nreadonly YELLOW='\\033[1;33m'\nreadonly BLUE='\\033[0;34m'\nreadonly NC='\\033[0m' # No Color\n\n# Logging functions\nlib_log_info() {\n    echo -e \"${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\nlib_log_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\nlib_log_warning() {\n    echo -e \"${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\nlib_log_error() {\n    echo -e \"${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\n# Check if script is run as root\nlib_require_root() {\n    if [[ $EUID -ne 0 ]]; then\n        lib_log_error \"This script must be run as root\"\n        return 1\n    fi\n    return 0\n}\n\n# Check if a command exists\nlib_command_exists() {\n    local cmd=\"$1\"\n    if command -v \"$cmd\" &> /dev/null; then\n        return 0\n    else\n        lib_log_error \"Command not found: $cmd\"\n        return 1\n    fi\n}\n\n# Check if file exists and is readable\nlib_file_readable() {\n    local file=\"$1\"\n    if [[ ! -f \"$file\" ]]; then\n        lib_log_error \"File not found: $file\"\n        return 1\n    elif [[ ! -r \"$file\" ]]; then\n        lib_log_error \"File not readable: $file\"\n        return 1\n    fi\n    return 0\n}\n\n# Check if directory exists\nlib_dir_exists() {\n    local dir=\"$1\"\n    if [[ ! -d \"$dir\" ]]; then\n        lib_log_error \"Directory not found: $dir\"\n        return 1\n    fi\n    return 0\n}\n\n# Create directory with error handling\nlib_mkdir_safe() {\n    local dir=\"$1\"\n    if [[ -d \"$dir\" ]]; then\n        lib_log_warning \"Directory already exists: $dir\"\n        return 0\n    fi\n    \n    if mkdir -p \"$dir\" 2>/dev/null; then\n        lib_log_success \"Created directory: $dir\"\n        return 0\n    else\n        lib_log_error \"Failed to create directory: $dir\"\n        return 1\n    fi\n}\n\n# Check if systemd service exists\nlib_service_exists() {\n    local service=\"$1\"\n    if systemctl list-unit-files \"${service}.service\" &> /dev/null; then\n        return 0\n    else\n        lib_log_error \"Service not found: $service\"\n        return 1\n    fi\n}\n\n# Check if service is running\nlib_service_running() {\n    local service=\"$1\"\n    if ! lib_service_exists \"$service\"; then\n        return 1\n    fi\n    \n    if systemctl is-active --quiet \"$service\"; then\n        lib_log_info \"Service is running: $service\"\n        return 0\n    else\n        lib_log_warning \"Service is not running: $service\"\n        return 1\n    fi\n}\n\n# Start service with error handling\nlib_service_start() {\n    local service=\"$1\"\n    lib_log_info \"Starting service: $service\"\n    \n    if systemctl start \"$service\" 2>&1; then\n        lib_log_success \"Service started: $service\"\n        return 0\n    else\n        lib_log_error \"Failed to start service: $service\"\n        return 1\n    fi\n}\n\n# Restart service with error handling\nlib_service_restart() {\n    local service=\"$1\"\n    lib_log_info \"Restarting service: $service\"\n    \n    if systemctl restart \"$service\" 2>&1; then\n        lib_log_success \"Service restarted: $service\"\n        return 0\n    else\n        lib_log_error \"Failed to restart service: $service\"\n        return 1\n    fi\n}\n\n# Check if port is open\nlib_port_open() {\n    local host=\"${1:-localhost}\"\n    local port=\"$2\"\n    local timeout=\"${3:-5}\"\n    \n    if timeout \"$timeout\" bash -c \"</dev/tcp/$host/$port\" 2>/dev/null; then\n        lib_log_info \"Port $port is open on $host\"\n        return 0\n    else\n        lib_log_warning \"Port $port is closed on $host\"\n        return 1\n    fi\n}\n\n# Wait for service to be ready (port check)\nlib_wait_for_port() {\n    local host=\"${1:-localhost}\"\n    local port=\"$2\"\n    local max_wait=\"${3:-60}\"\n    local wait_interval=\"${4:-2}\"\n    \n    lib_log_info \"Waiting for $host:$port to be available (max ${max_wait}s)\"\n    \n    local elapsed=0\n    while [[ $elapsed -lt $max_wait ]]; do\n        if lib_port_open \"$host\" \"$port\" 1; then\n            lib_log_success \"Port $port is now available on $host\"\n            return 0\n        fi\n        sleep \"$wait_interval\"\n        elapsed=$((elapsed + wait_interval))\n    done\n    \n    lib_log_error \"Timeout waiting for $host:$port\"\n    return 1\n}\n\n# Backup file with timestamp\nlib_backup_file() {\n    local file=\"$1\"\n    local backup_dir=\"${2:-/var/backups}\"\n    \n    if ! lib_file_readable \"$file\"; then\n        return 1\n    fi\n    \n    local timestamp=$(date +%Y%m%d_%H%M%S)\n    local filename=$(basename \"$file\")\n    local backup_path=\"${backup_dir}/${filename}.${timestamp}.bak\"\n    \n    if cp -p \"$file\" \"$backup_path\"; then\n        lib_log_success \"Backed up: $file -> $backup_path\"\n        echo \"$backup_path\"  # Return backup path\n        return 0\n    else\n        lib_log_error \"Failed to backup: $file\"\n        return 1\n    fi\n}\n\n# Prompt user for confirmation\nlib_confirm() {\n    local prompt=\"${1:-Are you sure?}\"\n    local default=\"${2:-n}\"  # y or n\n    \n    local response\n    if [[ \"$default\" == \"y\" ]]; then\n        read -r -p \"$prompt [Y/n]: \" response\n        response=${response:-y}\n    else\n        read -r -p \"$prompt [y/N]: \" response\n        response=${response:-n}\n    fi\n    \n    case \"$response\" in\n        [yY][eE][sS]|[yY])\n            return 0\n            ;;\n        *)\n            return 1\n            ;;\n    esac\n}\n\n# Check disk space (returns 1 if usage > threshold)\nlib_check_disk_space() {\n    local path=\"${1:-.}\"\n    local threshold=\"${2:-90}\"  # Default 90% threshold\n    \n    local usage=$(df -h \"$path\" | awk 'NR==2 {print $5}' | sed 's/%//')\n    \n    if [[ $usage -gt $threshold ]]; then\n        lib_log_error \"Disk usage is ${usage}% on $path (threshold: ${threshold}%)\"\n        return 1\n    else\n        lib_log_info \"Disk usage is ${usage}% on $path\"\n        return 0\n    fi\n}\n\nlib_log_info \"Sysadmin library loaded successfully\"\nEOF",
      "AGENT: ''",
      "Run command: `sudo chmod +x /usr/local/lib/sysadmin_lib.sh`",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Create Example Script Using the Library ---'",
      "Create tool: `cat > deploy_app.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Load the function library\nsource /usr/local/lib/sysadmin_lib.sh\n\nlib_log_info \"Starting application deployment\"\n\n# Check if running as root\nif ! lib_require_root; then\n    exit 1\nfi\n\n# Check required commands\nfor cmd in docker systemctl nginx; do\n    lib_command_exists \"$cmd\" || exit 1\ndone\n\n# Check disk space\nif ! lib_check_disk_space \"/var\" 80; then\n    lib_log_error \"Insufficient disk space on /var\"\n    exit 1\nfi\n\n# Confirm deployment\nif ! lib_confirm \"Deploy application to production?\"; then\n    lib_log_warning \"Deployment cancelled by user\"\n    exit 0\nfi\n\n# Backup existing configuration\nif lib_file_readable \"/etc/nginx/nginx.conf\"; then\n    backup_path=$(lib_backup_file \"/etc/nginx/nginx.conf\")\n    lib_log_info \"Configuration backed up to: $backup_path\"\nfi\n\n# Create deployment directory\nlib_mkdir_safe \"/opt/myapp\" || exit 1\n\n# Check if service is already running\nif lib_service_running \"myapp\"; then\n    lib_log_info \"Stopping existing service\"\n    sudo systemctl stop myapp\nfi\n\n# Deploy application (simulated)\nlib_log_info \"Deploying application files...\"\nsleep 2\n\n# Start service\nlib_service_start \"myapp\" || exit 1\n\n# Wait for app to be ready\nlib_wait_for_port \"localhost\" 8080 30 || exit 1\n\n# Restart nginx\nlib_service_restart \"nginx\" || exit 1\n\nlib_log_success \"Deployment completed successfully!\"\nEOF",
      "chmod +x deploy_app.sh",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Run the Example Script ---'",
      "Run command: `sudo ./deploy_app.sh`",
      "AGENT: '[INFO] 2025-10-07 15:00:00 - Sysadmin library loaded successfully'",
      "AGENT: '[INFO] 2025-10-07 15:00:00 - Starting application deployment'",
      "AGENT: '[INFO] 2025-10-07 15:00:01 - Command found: docker'",
      "AGENT: '[INFO] 2025-10-07 15:00:01 - Command found: systemctl'",
      "AGENT: '[INFO] 2025-10-07 15:00:01 - Command found: nginx'",
      "AGENT: '[INFO] 2025-10-07 15:00:01 - Disk usage is 65% on /var'",
      "AGENT: 'Deploy application to production? [y/N]: y'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:05 - Backed up: /etc/nginx/nginx.conf -> /var/backups/nginx.conf.20251007_150005.bak'",
      "AGENT: '[INFO] 2025-10-07 15:00:05 - Configuration backed up to: /var/backups/nginx.conf.20251007_150005.bak'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:05 - Created directory: /opt/myapp'",
      "AGENT: '[INFO] 2025-10-07 15:00:05 - Service is running: myapp'",
      "AGENT: '[INFO] 2025-10-07 15:00:05 - Stopping existing service'",
      "AGENT: '[INFO] 2025-10-07 15:00:06 - Deploying application files...'",
      "AGENT: '[INFO] 2025-10-07 15:00:08 - Starting service: myapp'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:09 - Service started: myapp'",
      "AGENT: '[INFO] 2025-10-07 15:00:09 - Waiting for localhost:8080 to be available (max 30s)'",
      "AGENT: '[INFO] 2025-10-07 15:00:11 - Port 8080 is open on localhost'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:11 - Port 8080 is now available on localhost'",
      "AGENT: '[INFO] 2025-10-07 15:00:11 - Restarting service: nginx'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:12 - Service restarted: nginx'",
      "AGENT: '[SUCCESS] 2025-10-07 15:00:12 - Deployment completed successfully!'",
      "AGENT: ''",
      "AGENT: 'âœ… Perfect! Clean, professional output with error handling at every step.'",
      "AGENT: ''",
      "AGENT: '--- Approach 4: Create Another Script Using Same Library ---'",
      "Create tool: `cat > health_check.sh << 'EOF'`",
      "#!/bin/bash\nsource /usr/local/lib/sysadmin_lib.sh\n\nlib_log_info \"Running system health check\"\n\n# Check critical services\nservices=(\"nginx\" \"postgresql\" \"redis\" \"myapp\")\nfor service in \"${services[@]}\"; do\n    if lib_service_running \"$service\"; then\n        lib_log_success \"âœ“ $service\"\n    else\n        lib_log_error \"âœ— $service is down!\"\n    fi\ndone\n\n# Check critical ports\nports=(\"80:nginx\" \"443:nginx-ssl\" \"5432:postgresql\" \"6379:redis\")\nfor entry in \"${ports[@]}\"; do\n    port=$(echo \"$entry\" | cut -d: -f1)\n    name=$(echo \"$entry\" | cut -d: -f2)\n    if lib_port_open \"localhost\" \"$port\" 2; then\n        lib_log_success \"âœ“ Port $port ($name)\"\n    else\n        lib_log_error \"âœ— Port $port ($name) is not responding!\"\n    fi\ndone\n\n# Check disk space on critical mounts\nfor mount in \"/\" \"/var\" \"/opt\"; do\n    if lib_check_disk_space \"$mount\" 85; then\n        lib_log_success \"âœ“ Disk space OK on $mount\"\n    else\n        lib_log_error \"âœ— Disk space critical on $mount!\"\n    fi\ndone\n\nlib_log_info \"Health check completed\"\nEOF",
      "chmod +x health_check.sh",
      "AGENT: ''",
      "AGENT: '--- Approach 5: Test Health Check Script ---'",
      "Run command: `./health_check.sh`",
      "AGENT: '[INFO] 2025-10-07 15:05:00 - Running system health check'",
      "AGENT: '[INFO] 2025-10-07 15:05:00 - Service is running: nginx'",
      "AGENT: '[SUCCESS] 2025-10-07 15:05:00 - âœ“ nginx'",
      "AGENT: '[INFO] 2025-10-07 15:05:00 - Service is running: postgresql'",
      "AGENT: '[SUCCESS] 2025-10-07 15:05:00 - âœ“ postgresql'",
      "AGENT: '[WARNING] 2025-10-07 15:05:00 - Service is not running: redis'",
      "AGENT: '[ERROR] 2025-10-07 15:05:00 - âœ— redis is down!'",
      "AGENT: '[INFO] 2025-10-07 15:05:00 - Port 80 is open on localhost'",
      "AGENT: '[SUCCESS] 2025-10-07 15:05:00 - âœ“ Port 80 (nginx)'",
      "AGENT: '[INFO] 2025-10-07 15:05:02 - Disk usage is 45% on /'",
      "AGENT: '[SUCCESS] 2025-10-07 15:05:02 - âœ“ Disk space OK on /'",
      "AGENT: '[INFO] 2025-10-07 15:05:02 - Health check completed'",
      "AGENT: ''",
      "AGENT: 'âœ… Same library, different script - clean and consistent!'",
      "AGENT: ''",
      "AGENT: 'âœ“ SOLUTION SUMMARY:'",
      "AGENT: '  âœ“ Created comprehensive bash function library with 15+ reusable functions.'",
      "AGENT: '  âœ“ Implemented proper error handling with return codes and error messages.'",
      "AGENT: '  âœ“ Added colored logging (INFO, SUCCESS, WARNING, ERROR) for clear output.'",
      "AGENT: '  âœ“ Built functions for common tasks: service management, file operations, networking.'",
      "AGENT: '  âœ“ Created validation functions (root check, file exists, command exists).'",
      "AGENT: '  âœ“ Demonstrated reusability across multiple scripts.'",
      "AGENT: '  âœ“ Followed bash best practices: set -euo pipefail, parameter validation, descriptive names.'",
      "AGENT: '  âœ“ You now have a professional bash library for all your automation needs! ðŸ“š'"
    ],
    "commands": ["cat", "chmod", "sudo", "bash", "source"],
    "packages": {
      "debian_ubuntu": ["bash", "coreutils"],
      "arch": ["bash", "coreutils"]
    },
    "related_commands": ["function", "return", "exit"],
    "complexity": "advanced",
    "tags": ["bash", "shell-scripting", "functions", "library", "automation", "error-handling", "best-practices", "reusability"]
  }
]
