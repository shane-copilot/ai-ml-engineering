[
  {
    "id": "cmd_sed_001",
    "command": "sed",
    "scenario": "Find and replace text in files",
    "problem": "Need to replace all occurrences of a string across one or multiple files",
    "solution": "Use sed stream editor for text substitution",
    "steps": [
      "Basic replace (first occurrence per line): sed 's/old/new/' file.txt",
      "Replace all occurrences (global): sed 's/old/new/g' file.txt",
      "In-place edit (modify file): sed -i 's/old/new/g' file.txt",
      "Backup before edit: sed -i.bak 's/old/new/g' file.txt",
      "Creates file.txt.bak",
      "Case-insensitive: sed 's/old/new/gi' file.txt",
      "Multiple files: sed -i 's/old/new/g' *.txt",
      "Preview changes first: sed 's/old/new/g' file.txt | diff file.txt -",
      "Replace only on specific line: sed '3s/old/new/' file.txt",
      "Line 3 only",
      "Range of lines: sed '10,20s/old/new/g' file.txt",
      "Lines 10 to 20",
      "From line to end: sed '5,$s/old/new/g' file.txt",
      "Delete lines containing pattern: sed '/pattern/d' file.txt",
      "Delete specific line: sed '5d' file.txt",
      "Delete range: sed '10,20d' file.txt",
      "Delete empty lines: sed '/^$/d' file.txt",
      "Insert line before: sed '5i\\New line text' file.txt",
      "Insert after: sed '5a\\New line text' file.txt",
      "Print specific lines: sed -n '10,20p' file.txt",
      "-n suppresses default output, p=print",
      "Replace with special characters: sed 's/\\/path\\/old/\\/path\\/new/g' file.txt",
      "Or use different delimiter: sed 's|/path/old|/path/new|g' file.txt",
      "Remove whitespace: sed 's/ *$//' file.txt (trailing spaces)",
      "Or: sed 's/^ *//' file.txt (leading spaces)",
      "Replace newlines: sed ':a;N;$!ba;s/\\n/ /g' file.txt",
      "Add line numbers: sed = file.txt | sed 'N;s/\\n/\\t/'",
      "Extract between patterns: sed -n '/START/,/END/p' file.txt",
      "Multiple substitutions: sed 's/old1/new1/g; s/old2/new2/g' file.txt",
      "Or use multiple -e: sed -e 's/old1/new1/g' -e 's/old2/new2/g' file.txt",
      "From script file: sed -f script.sed file.txt",
      "Comment lines: sed 's/^/#/' file.txt",
      "Uncomment: sed 's/^#//' file.txt",
      "Replace only if line matches: sed '/pattern/s/old/new/g' file.txt",
      "Capitalize: sed 's/\\(.*\\)/\\U\\1/' file.txt",
      "Lowercase: sed 's/\\(.*\\)/\\L\\1/' file.txt",
      "DOS to Unix: sed 's/\\r$//' file.txt",
      "Unix to DOS: sed 's/$/\\r/' file.txt",
      "Remove HTML tags: sed 's/<[^>]*>//g' file.html",
      "Extract email: sed -n 's/.*\\([a-zA-Z0-9.]*@[a-zA-Z0-9.]*\\).*/\\1/p' file.txt",
      "Recursive replacement: find . -name '*.txt' -exec sed -i 's/old/new/g' {} \\;",
      "With confirmation: find . -name '*.txt' -exec sed -i.bak 's/old/new/g' {} \\;",
      "Then check .bak files"
    ],
    "commands": ["sed", "diff", "find"],
    "packages": {
      "debian_ubuntu": ["sed"],
      "arch": ["sed"]
    },
    "related_commands": ["awk", "grep", "tr", "perl"],
    "complexity": "intermediate",
    "tags": ["sed", "text-processing", "find-replace", "stream-editor", "regex"]
  },
  {
    "id": "cmd_awk_001",
    "command": "awk",
    "scenario": "Extract and process specific columns from text output",
    "problem": "Command output has multiple columns, need to extract and process specific fields",
    "solution": "Use awk to parse and manipulate column-based data",
    "steps": [
      "Print specific column: awk '{print $1}' file.txt",
      "$1 = first column, $2 = second, etc.",
      "Multiple columns: awk '{print $1, $3}' file.txt",
      "Comma adds space between",
      "All columns: awk '{print $0}' file.txt",
      "$0 = entire line",
      "Last column: awk '{print $NF}' file.txt",
      "NF = number of fields",
      "Second to last: awk '{print $(NF-1)}' file.txt",
      "With custom separator: awk -F: '{print $1}' /etc/passwd",
      "F sets field separator (: in this case)",
      "Multiple separators: awk -F'[,:]' '{print $1}' file.txt",
      "Output separator: awk 'BEGIN{OFS=\"|\"} {print $1,$2}' file.txt",
      "Pattern matching: awk '/pattern/ {print $1}' file.txt",
      "Only lines matching pattern",
      "Negation: awk '!/pattern/ {print $1}' file.txt",
      "Conditional: awk '$3 > 100 {print $1}' file.txt",
      "Print if column 3 > 100",
      "Multiple conditions: awk '$3 > 100 && $4 < 200 {print $1}' file.txt",
      "Sum column: awk '{sum+=$3} END {print sum}' file.txt",
      "Average: awk '{sum+=$3; count++} END {print sum/count}' file.txt",
      "Count lines: awk 'END {print NR}' file.txt",
      "NR = number of records/lines",
      "Line numbers: awk '{print NR, $0}' file.txt",
      "String concatenation: awk '{print $1 \"-\" $2}' file.txt",
      "Length of field: awk '{print length($1)}' file.txt",
      "Substring: awk '{print substr($1,1,5)}' file.txt",
      "First 5 chars of column 1",
      "Uppercase: awk '{print toupper($1)}' file.txt",
      "Lowercase: awk '{print tolower($1)}' file.txt",
      "Split and process: awk -F, '{for(i=1;i<=NF;i++) print $i}' file.csv",
      "Remove duplicates: awk '!seen[$0]++' file.txt",
      "Column statistics: awk '{sum+=$1; sumsq+=$1*$1} END {print \"avg:\",sum/NR,\"std:\",sqrt(sumsq/NR - (sum/NR)^2)}' data.txt",
      "Format output: awk '{printf \"%-10s %5d\\n\", $1, $2}' file.txt",
      "Process /etc/passwd: awk -F: '{print \"User: \" $1 \", Home: \" $6}' /etc/passwd",
      "Process ps output: ps aux | awk '$3 > 50 {print $2, $11}'",
      "PIDs using >50% CPU",
      "Disk usage: df -h | awk '$5+0 > 80 {print $6, $5}'",
      "Mounts over 80% full",
      "Log analysis: awk '/ERROR/ {count++} END {print count}' /var/log/syslog",
      "CSV processing: awk -F, '{print $1,$3}' OFS=, file.csv",
      "With header: awk 'NR==1 {print; next} {print $1,$3}' file.csv",
      "BEGIN block: awk 'BEGIN {print \"Starting...\"} {print $1} END {print \"Done\"}' file.txt",
      "Multi-line script: awk 'script.awk' file.txt",
      "Or: awk -f script.awk file.txt"
    ],
    "commands": ["awk", "ps", "df"],
    "packages": {
      "debian_ubuntu": ["gawk"],
      "arch": ["gawk"]
    },
    "related_commands": ["sed", "cut", "grep", "sort", "uniq"],
    "complexity": "intermediate",
    "tags": ["awk", "text-processing", "columns", "parsing", "data-extraction"]
  },
  {
    "id": "cmd_cut_001",
    "command": "cut",
    "scenario": "Extract specific fields from delimited text",
    "problem": "Need to extract specific columns from CSV or tab-delimited data",
    "solution": "Use cut to select specific fields from each line",
    "steps": [
      "Extract first field (default tab delimiter): cut -f1 file.txt",
      "Multiple fields: cut -f1,3,5 file.txt",
      "Fields 1, 3, and 5",
      "Range of fields: cut -f2-5 file.txt",
      "Fields 2 through 5",
      "From field to end: cut -f3- file.txt",
      "Field 3 to last",
      "Up to field: cut -f-4 file.txt",
      "First through field 4",
      "Custom delimiter (CSV): cut -d, -f1,2 file.csv",
      "-d sets delimiter",
      "Colon delimiter: cut -d: -f1,6 /etc/passwd",
      "Username and home directory",
      "Space delimiter: cut -d' ' -f2 file.txt",
      "Extract by character position: cut -c1-10 file.txt",
      "First 10 characters",
      "Specific characters: cut -c1,5,9 file.txt",
      "Complement (everything except): cut -d, -f2 --complement file.csv",
      "All fields except field 2",
      "Output delimiter: cut -d, -f1,3 --output-delimiter=' | ' file.csv",
      "Changes delimiter in output",
      "Suppress lines without delimiter: cut -d: -f1 -s /etc/passwd",
      "-s only shows lines with delimiter",
      "From command output: ps aux | cut -c1-20",
      "First 20 chars of each line",
      "Extract IP addresses: ifconfig | grep 'inet ' | cut -d' ' -f10",
      "Or: ip addr | grep inet | cut -d' ' -f6 | cut -d/ -f1",
      "Extract users: cut -d: -f1 /etc/passwd",
      "Extract filenames: ls -l | cut -d' ' -f9-",
      "Ninth field to end",
      "CSV first column: cut -d, -f1 data.csv",
      "Multiple delimiter issue: Use awk for multiple spaces",
      "cut doesn't handle repeated delimiters well",
      "Workaround: tr -s ' ' | cut -d' ' -f2",
      "tr -s squeezes repeated spaces",
      "Extract from log: cut -d' ' -f4- /var/log/syslog | cut -d: -f1",
      "Combine with grep: grep 'ERROR' file.log | cut -d' ' -f3-5",
      "Pipe to cut: cat file.txt | cut -f2,4",
      "Sort and cut: sort file.txt | cut -f1 | uniq",
      "With sed for cleaning: cut -d, -f1 file.csv | sed 's/\"//g'",
      "Remove quotes",
      "Count unique: cut -d: -f7 /etc/passwd | sort | uniq -c",
      "Shell usage count",
      "Process multiple files: cut -d, -f1 *.csv",
      "Character range: cut -c5-15 file.txt",
      "Bytes instead of chars: cut -b1-10 file.txt",
      "For multibyte characters"
    ],
    "commands": ["cut", "grep", "tr", "sort", "uniq", "awk", "sed"],
    "packages": {
      "debian_ubuntu": ["coreutils"],
      "arch": ["coreutils"]
    },
    "related_commands": ["awk", "sed", "grep", "tr", "paste"],
    "complexity": "beginner",
    "tags": ["cut", "text-processing", "csv", "fields", "columns", "parsing"]
  },
  {
    "id": "cmd_sort_001",
    "command": "sort",
    "scenario": "Sort and organize text data",
    "problem": "Need to sort command output or file contents alphabetically, numerically, or by specific fields",
    "solution": "Use sort with various options to organize data",
    "steps": [
      "Basic alphabetical sort: sort file.txt",
      "Reverse order: sort -r file.txt",
      "Numeric sort: sort -n numbers.txt",
      "Treats fields as numbers (1, 2, 10 vs 1, 10, 2)",
      "Human-readable numbers: sort -h sizes.txt",
      "Handles K, M, G suffixes (1K, 1M, 1G)",
      "Case-insensitive: sort -f file.txt",
      "Unique lines only: sort -u file.txt",
      "Combines sort and uniq",
      "Sort by specific field: sort -k2 file.txt",
      "Sorts by field 2 (space-separated)",
      "Custom delimiter: sort -t: -k3 /etc/passwd",
      "-t sets delimiter, -k3 sorts by field 3",
      "Multiple keys: sort -k2,2 -k3,3n file.txt",
      "First by field 2, then by field 3 numerically",
      "Reverse specific field: sort -k2,2r file.txt",
      "Month sort: sort -M months.txt",
      "Understands Jan, Feb, Mar, etc.",
      "Version sort: sort -V versions.txt",
      "For version numbers like 1.0, 1.1, 1.10",
      "Random order: sort -R file.txt",
      "Check if sorted: sort -c file.txt",
      "Returns error if not sorted",
      "Merge sorted files: sort -m file1.txt file2.txt",
      "Output to file: sort file.txt -o sorted.txt",
      "Sort in-place: sort -o file.txt file.txt",
      "Stable sort (preserve order): sort -s file.txt",
      "Ignore leading blanks: sort -b file.txt",
      "Dictionary order: sort -d file.txt",
      "Only alphanumeric and blanks",
      "Parallel processing: sort --parallel=4 file.txt",
      "Faster on large files",
      "Temporary directory: sort -T /tmp file.txt",
      "Buffer size: sort -S 50% file.txt",
      "Use 50% of available memory",
      "Common usage patterns:",
      "Sort by size: ls -l | sort -k5 -n",
      "Disk usage sorted: du -sh /* | sort -h",
      "Processes by memory: ps aux | sort -k4 -rn | head",
      "Sort IPs: sort -t. -k1,1n -k2,2n -k3,3n -k4,4n ips.txt",
      "Log timestamps: sort -k1,1 -k2,2 logfile.txt",
      "CSV by column: sort -t, -k2 file.csv",
      "Unique sorted: sort file.txt | uniq",
      "Or: sort -u file.txt",
      "Count duplicates: sort file.txt | uniq -c | sort -rn",
      "Sort then cut: sort -t: -k3 -n /etc/passwd | cut -d: -f1,3",
      "Case study: Top bandwidth users",
      "Command: netstat -tn | tail -n +3 | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr | head",
      "Sorts connections by count",
      "Find duplicate files: find . -type f -exec md5sum {} \\; | sort | uniq -w32 -d"
    ],
    "commands": ["sort", "uniq", "ls", "du", "ps", "cut", "awk", "find", "md5sum"],
    "packages": {
      "debian_ubuntu": ["coreutils"],
      "arch": ["coreutils"]
    },
    "related_commands": ["uniq", "grep", "awk", "cut"],
    "complexity": "intermediate",
    "tags": ["sort", "text-processing", "sorting", "organization", "data-manipulation"]
  },
  {
    "id": "cmd_kill_001",
    "command": "kill",
    "scenario": "Terminate unresponsive or problematic processes",
    "problem": "Application is frozen or consuming too many resources, needs to be stopped",
    "solution": "Use kill with appropriate signals to terminate processes",
    "steps": [
      "Find process first: ps aux | grep process_name",
      "Or: pgrep -l process_name",
      "Or: pidof process_name",
      "Get PID (process ID) from output",
      "Graceful termination (SIGTERM): kill <PID>",
      "Default signal 15, allows cleanup",
      "Example: kill 1234",
      "Force kill (SIGKILL): kill -9 <PID>",
      "Signal 9, immediate termination, no cleanup",
      "Example: kill -9 1234",
      "Use -9 only if normal kill doesn't work",
      "Reload configuration (SIGHUP): kill -HUP <PID>",
      "Signal 1, many daemons reload config",
      "Example: kill -HUP $(cat /var/run/nginx.pid)",
      "List all signals: kill -l",
      "Shows signal numbers and names",
      "Signal by name: kill -SIGTERM <PID>",
      "Or: kill -TERM <PID>",
      "Stop process (SIGSTOP): kill -STOP <PID>",
      "Pauses process, can resume later",
      "Continue process (SIGCONT): kill -CONT <PID>",
      "Resumes stopped process",
      "User signals: kill -USR1 <PID> or kill -USR2 <PID>",
      "Application-specific behavior",
      "Kill by process name: killall process_name",
      "Terminates all processes with that name",
      "Example: killall firefox",
      "Killall with signal: killall -9 process_name",
      "Pattern matching: pkill -f pattern",
      "Kills processes matching pattern",
      "Example: pkill -f 'python script.py'",
      "Kill by user: pkill -u username",
      "All processes owned by user",
      "Interactive kill: kill -9 $(pgrep -f pattern)",
      "Combine pgrep and kill",
      "Kill process tree: kill -TERM -<PGID>",
      "Negative PID kills process group",
      "Find PGID: ps -o pgid= <PID>",
      "Kill with timeout: timeout 10 kill <PID> || kill -9 <PID>",
      "Try normal kill, force after timeout",
      "Check if process killed: ps -p <PID>",
      "Returns nothing if process gone",
      "Wait for process to die: tail --pid=<PID> -f /dev/null",
      "Blocks until process exits",
      "Kill hung SSH: Get PID from ps aux | grep ssh, then kill <PID>",
      "Kill terminal: kill -9 $$ (kills current shell)",
      "All children too: kill -TERM -$$",
      "Common scenarios:",
      "Frozen Firefox: killall -9 firefox",
      "Hung SSH: ps aux | grep 'ssh.*host' then kill <PID>",
      "Python script: pkill -f 'python.*myscript.py'",
      "Zombie processes: Can't kill zombies directly, kill parent process",
      "Find parent: ps -o ppid= <zombie_PID>",
      "All user processes: pkill -u $USER (careful!)",
      "Graceful restart: kill -HUP <PID> (for daemons)",
      "Last resort: kill -9 <PID> (may cause data loss)",
      "After killing: Verify with ps -p <PID> or pgrep -l process_name"
    ],
    "commands": ["kill", "killall", "pkill", "pgrep", "pidof", "ps", "timeout", "tail"],
    "packages": {
      "debian_ubuntu": ["procps", "psmisc"],
      "arch": ["procps-ng", "psmisc"]
    },
    "related_commands": ["killall", "pkill", "pgrep", "ps", "top", "htop"],
    "complexity": "beginner",
    "tags": ["kill", "process-management", "signals", "terminate", "sigterm", "sigkill"]
  }
]
