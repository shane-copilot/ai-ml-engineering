[
  {
    "id": "scenario_python_scripting_142",
    "command": "python3",
    "scenario": "Use Python for system administration, automation, and data processing tasks.",
    "problem": "Need to automate system tasks, process files, parse logs, interact with APIs, handle JSON/CSV data, create command-line tools, and write maintainable Python scripts for daily operations.",
    "solution": "Master Python scripting with standard library modules (os, sys, subprocess, argparse, pathlib), file I/O, JSON/CSV processing, HTTP requests, error handling, and create practical automation scripts.",
    "steps": [
      "USER SAYS: 'How do I use Python for automation and system administration tasks? I need to process files, run commands, and parse data.'",
      "AGENT: 'Let me show you Python scripting! We'll cover file operations, subprocess, argparse, JSON/CSV, APIs, and practical automation examples.'",
      "AGENT: ''",
      "AGENT: '🔍 RESEARCH PHASE: Python scripting for automation...'",
      "AGENT: '[Searching] \"python scripting automation subprocess argparse file processing\"'",
      "AGENT: '[Found] subprocess for running shell commands.'",
      "AGENT: '[Found] pathlib for modern file path handling.'",
      "AGENT: '[Found] argparse for CLI arguments, json/csv for data.'",
      "AGENT: '[Found] requests for API calls, standard library is powerful.'",
      "AGENT: '✓ Research complete! Let's master Python scripting.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Running Shell Commands ---'",
      "Create tool: `cat > run_commands.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport subprocess\n\n# Run simple command\nresult = subprocess.run(['ls', '-la'], capture_output=True, text=True)\nprint('Exit code:', result.returncode)\nprint('Output:', result.stdout)\n\n# Run command with shell\nresult = subprocess.run('echo \"Hello\" | wc -l', shell=True, capture_output=True, text=True)\nprint('Word count:', result.stdout.strip())\n\n# Check if command succeeded\ntry:\n    subprocess.run(['ls', '/nonexistent'], check=True)\nexcept subprocess.CalledProcessError as e:\n    print(f'Command failed with code {e.returncode}')\n\n# Get command output\noutput = subprocess.check_output(['whoami']).decode().strip()\nprint(f'Current user: {output}')\nEOF",
      "Run command: `chmod +x run_commands.py && python3 run_commands.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 2: File Operations with Pathlib ---'",
      "Create tool: `cat > file_ops.py << 'EOF'`",
      "#!/usr/bin/env python3\nfrom pathlib import Path\nimport shutil\n\n# Create directory\nPath('test_dir').mkdir(exist_ok=True)\n\n# Create file\nfile_path = Path('test_dir/example.txt')\nfile_path.write_text('Hello, World!')\n\n# Read file\ncontent = file_path.read_text()\nprint(f'Content: {content}')\n\n# Check if exists\nif file_path.exists():\n    print(f'{file_path} exists')\n    print(f'Size: {file_path.stat().st_size} bytes')\n    print(f'Is file: {file_path.is_file()}')\n    print(f'Is dir: {file_path.is_dir()}')\n\n# List files\nprint('\\nFiles in test_dir:')\nfor item in Path('test_dir').iterdir():\n    print(f'  {item.name} ({\"file\" if item.is_file() else \"dir\"})')\n\n# Find files by pattern\nprint('\\n.txt files:')\nfor txt_file in Path('.').glob('**/*.txt'):\n    print(f'  {txt_file}')\n\n# Copy file\nshutil.copy(file_path, 'test_dir/example_copy.txt')\n\n# Move/rename file\nfile_path.rename('test_dir/renamed.txt')\n\n# Delete file\nPath('test_dir/renamed.txt').unlink()\n\n# Delete directory\nshutil.rmtree('test_dir')\nprint('\\nCleanup complete!')\nEOF",
      "Run command: `python3 file_ops.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Command-Line Arguments with Argparse ---'",
      "Create tool: `cat > cli_tool.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport argparse\nimport sys\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Example CLI tool',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog='''\nExamples:\n  %(prog)s -i input.txt -o output.txt\n  %(prog)s --verbose process data.csv\n        '''\n    )\n    \n    # Required arguments\n    parser.add_argument('-i', '--input', required=True, help='Input file')\n    parser.add_argument('-o', '--output', required=True, help='Output file')\n    \n    # Optional arguments\n    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')\n    parser.add_argument('-n', '--number', type=int, default=10, help='Number (default: 10)')\n    parser.add_argument('--format', choices=['json', 'csv', 'txt'], default='txt', help='Output format')\n    \n    # Positional arguments\n    parser.add_argument('command', choices=['process', 'validate', 'convert'], help='Command to execute')\n    parser.add_argument('files', nargs='+', help='Files to process')\n    \n    args = parser.parse_args()\n    \n    # Use arguments\n    if args.verbose:\n        print(f'Input: {args.input}')\n        print(f'Output: {args.output}')\n        print(f'Command: {args.command}')\n        print(f'Files: {\", \".join(args.files)}')\n        print(f'Number: {args.number}')\n        print(f'Format: {args.format}')\n    \n    print(f'Processing {len(args.files)} files...')\n\nif __name__ == '__main__':\n    main()\nEOF",
      "Run command: `chmod +x cli_tool.py`",
      "Run command: `python3 cli_tool.py -h`",
      "AGENT: 'Shows help message'",
      "AGENT: ''",
      "Run command: `python3 cli_tool.py -i input.txt -o output.txt process file1.txt file2.txt -v`",
      "AGENT: ''",
      "AGENT: '--- Approach 4: JSON Processing ---'",
      "Create tool: `cat > json_ops.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport json\nfrom pathlib import Path\n\n# Create JSON data\ndata = {\n    'name': 'John Doe',\n    'age': 30,\n    'email': 'john@example.com',\n    'skills': ['Python', 'Linux', 'Docker'],\n    'active': True\n}\n\n# Write JSON to file\nwith open('data.json', 'w') as f:\n    json.dump(data, f, indent=2)\n\nprint('JSON written to data.json')\n\n# Read JSON from file\nwith open('data.json', 'r') as f:\n    loaded_data = json.load(f)\n\nprint('\\nLoaded data:')\nprint(f'Name: {loaded_data[\"name\"]}')\nprint(f'Skills: {\", \".join(loaded_data[\"skills\"])}')\n\n# Parse JSON string\njson_string = '{\"status\": \"success\", \"count\": 42}'\nparsed = json.loads(json_string)\nprint(f'\\nStatus: {parsed[\"status\"]}, Count: {parsed[\"count\"]}')\n\n# Pretty print JSON\nprint('\\nPretty printed:')\nprint(json.dumps(data, indent=2, sort_keys=True))\n\n# Cleanup\nPath('data.json').unlink()\nEOF",
      "Run command: `python3 json_ops.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 5: CSV Processing ---'",
      "Create tool: `cat > csv_ops.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport csv\nfrom pathlib import Path\n\n# Write CSV\ndata = [\n    ['Name', 'Age', 'City'],\n    ['Alice', '30', 'New York'],\n    ['Bob', '25', 'London'],\n    ['Charlie', '35', 'Tokyo']\n]\n\nwith open('users.csv', 'w', newline='') as f:\n    writer = csv.writer(f)\n    writer.writerows(data)\n\nprint('CSV written to users.csv')\n\n# Read CSV\nprint('\\nReading CSV:')\nwith open('users.csv', 'r') as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(', '.join(row))\n\n# Read CSV with DictReader\nprint('\\nReading as dictionaries:')\nwith open('users.csv', 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(f\"{row['Name']} is {row['Age']} years old and lives in {row['City']}\")\n\n# Write CSV with DictWriter\nnew_data = [\n    {'Product': 'Laptop', 'Price': '999', 'Stock': '10'},\n    {'Product': 'Mouse', 'Price': '29', 'Stock': '50'}\n]\n\nwith open('products.csv', 'w', newline='') as f:\n    fieldnames = ['Product', 'Price', 'Stock']\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writeheader()\n    writer.writerows(new_data)\n\nprint('\\nProducts CSV created')\n\n# Cleanup\nPath('users.csv').unlink()\nPath('products.csv').unlink()\nEOF",
      "Run command: `python3 csv_ops.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 6: HTTP Requests (APIs) ---'",
      "Run command: `pip3 install requests`",
      "AGENT: ''",
      "Create tool: `cat > api_client.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport requests\nimport json\n\n# GET request\nresponse = requests.get('https://api.github.com/users/github')\nif response.status_code == 200:\n    data = response.json()\n    print(f\"User: {data['name']}\")\n    print(f\"Public repos: {data['public_repos']}\")\nelse:\n    print(f\"Error: {response.status_code}\")\n\n# POST request with JSON\ndata = {'title': 'Test', 'body': 'Content', 'userId': 1}\nresponse = requests.post(\n    'https://jsonplaceholder.typicode.com/posts',\n    json=data\n)\nprint(f\"\\nCreated post ID: {response.json()['id']}\")\n\n# Request with headers\nheaders = {\n    'Authorization': 'Bearer YOUR_TOKEN',\n    'Content-Type': 'application/json'\n}\nresponse = requests.get('https://api.example.com/data', headers=headers)\n\n# Query parameters\nparams = {'page': 1, 'limit': 10}\nresponse = requests.get('https://api.example.com/items', params=params)\n# Actual URL: https://api.example.com/items?page=1&limit=10\n\n# Error handling\ntry:\n    response = requests.get('https://api.example.com/data', timeout=5)\n    response.raise_for_status()  # Raises exception for 4xx/5xx\nexcept requests.exceptions.RequestException as e:\n    print(f\"Request failed: {e}\")\nEOF",
      "Run command: `python3 api_client.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 7: Log File Parser ---'",
      "Create tool: `cat > log_parser.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport re\nfrom collections import Counter\nfrom pathlib import Path\n\n# Create sample log\nlog_content = '''\n192.168.1.100 - - [08/Oct/2025:10:00:00] \"GET /api/users HTTP/1.1\" 200 1234\n192.168.1.101 - - [08/Oct/2025:10:00:05] \"POST /api/login HTTP/1.1\" 200 567\n192.168.1.100 - - [08/Oct/2025:10:00:10] \"GET /api/products HTTP/1.1\" 404 89\n192.168.1.102 - - [08/Oct/2025:10:00:15] \"GET /api/users HTTP/1.1\" 200 1234\n192.168.1.101 - - [08/Oct/2025:10:00:20] \"POST /api/logout HTTP/1.1\" 500 0\n'''\n\nPath('access.log').write_text(log_content)\n\n# Parse log file\nip_pattern = r'^([\\d.]+)'\nmethod_pattern = r'\"(GET|POST|PUT|DELETE)'\nstatus_pattern = r'\" (\\d{3}) '\n\nips = []\nmethods = []\nstatuses = []\n\nwith open('access.log', 'r') as f:\n    for line in f:\n        ip_match = re.search(ip_pattern, line)\n        if ip_match:\n            ips.append(ip_match.group(1))\n        \n        method_match = re.search(method_pattern, line)\n        if method_match:\n            methods.append(method_match.group(1))\n        \n        status_match = re.search(status_pattern, line)\n        if status_match:\n            statuses.append(int(status_match.group(1)))\n\n# Statistics\nprint('=== Log Analysis ===')\nprint(f'\\nTotal requests: {len(ips)}')\n\nprint('\\nTop IPs:')\nfor ip, count in Counter(ips).most_common(3):\n    print(f'  {ip}: {count} requests')\n\nprint('\\nHTTP Methods:')\nfor method, count in Counter(methods).items():\n    print(f'  {method}: {count}')\n\nprint('\\nStatus Codes:')\nfor status, count in Counter(statuses).items():\n    print(f'  {status}: {count}')\n\nerrors = [s for s in statuses if s >= 400]\nprint(f'\\nErrors: {len(errors)}/{len(statuses)} ({len(errors)/len(statuses)*100:.1f}%)')\n\n# Cleanup\nPath('access.log').unlink()\nEOF",
      "Run command: `python3 log_parser.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 8: File Backup Script ---'",
      "Create tool: `cat > backup.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport shutil\nimport argparse\nfrom pathlib import Path\nfrom datetime import datetime\n\ndef backup_directory(source, dest_base, compress=False):\n    '''Backup directory with timestamp'''\n    source = Path(source)\n    if not source.exists():\n        raise ValueError(f'Source does not exist: {source}')\n    \n    # Create timestamped backup name\n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    backup_name = f'{source.name}_{timestamp}'\n    dest = Path(dest_base) / backup_name\n    \n    print(f'Backing up {source} to {dest}')\n    \n    if compress:\n        # Create compressed archive\n        archive_path = shutil.make_archive(\n            str(dest),\n            'gztar',  # tar.gz format\n            source.parent,\n            source.name\n        )\n        print(f'Created archive: {archive_path}')\n        size = Path(archive_path).stat().st_size\n        print(f'Size: {size / 1024 / 1024:.2f} MB')\n    else:\n        # Copy directory\n        shutil.copytree(source, dest)\n        print(f'Copied to: {dest}')\n    \n    return dest\n\ndef main():\n    parser = argparse.ArgumentParser(description='Backup utility')\n    parser.add_argument('source', help='Source directory')\n    parser.add_argument('-d', '--dest', default='/backup', help='Destination directory')\n    parser.add_argument('-c', '--compress', action='store_true', help='Create compressed archive')\n    \n    args = parser.parse_args()\n    \n    try:\n        backup_directory(args.source, args.dest, args.compress)\n        print('Backup completed successfully!')\n    except Exception as e:\n        print(f'Backup failed: {e}')\n        return 1\n    \n    return 0\n\nif __name__ == '__main__':\n    exit(main())\nEOF",
      "Run command: `chmod +x backup.py`",
      "AGENT: ''",
      "AGENT: '--- Approach 9: System Monitor Script ---'",
      "Create tool: `cat > monitor.py << 'EOF'`",
      "#!/usr/bin/env python3\nimport psutil\nimport time\nfrom datetime import datetime\n\ndef get_system_info():\n    '''Get current system metrics'''\n    # CPU\n    cpu_percent = psutil.cpu_percent(interval=1)\n    cpu_count = psutil.cpu_count()\n    \n    # Memory\n    mem = psutil.virtual_memory()\n    mem_used_gb = mem.used / (1024**3)\n    mem_total_gb = mem.total / (1024**3)\n    \n    # Disk\n    disk = psutil.disk_usage('/')\n    disk_used_gb = disk.used / (1024**3)\n    disk_total_gb = disk.total / (1024**3)\n    \n    # Network\n    net = psutil.net_io_counters()\n    \n    return {\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n        'cpu_percent': cpu_percent,\n        'cpu_count': cpu_count,\n        'mem_used_gb': mem_used_gb,\n        'mem_total_gb': mem_total_gb,\n        'mem_percent': mem.percent,\n        'disk_used_gb': disk_used_gb,\n        'disk_total_gb': disk_total_gb,\n        'disk_percent': disk.percent,\n        'net_sent_mb': net.bytes_sent / (1024**2),\n        'net_recv_mb': net.bytes_recv / (1024**2)\n    }\n\ndef display_info(info):\n    '''Display system information'''\n    print(f\"\\n=== System Monitor - {info['timestamp']} ===\")\n    print(f\"CPU: {info['cpu_percent']:.1f}% ({info['cpu_count']} cores)\")\n    print(f\"Memory: {info['mem_used_gb']:.1f}/{info['mem_total_gb']:.1f} GB ({info['mem_percent']:.1f}%)\")\n    print(f\"Disk: {info['disk_used_gb']:.1f}/{info['disk_total_gb']:.1f} GB ({info['disk_percent']:.1f}%)\")\n    print(f\"Network: ↑ {info['net_sent_mb']:.1f} MB ↓ {info['net_recv_mb']:.1f} MB\")\n    \n    # Warnings\n    if info['cpu_percent'] > 80:\n        print(\"⚠️  High CPU usage!\")\n    if info['mem_percent'] > 80:\n        print(\"⚠️  High memory usage!\")\n    if info['disk_percent'] > 80:\n        print(\"⚠️  Low disk space!\")\n\ndef main():\n    print(\"Starting system monitor (Ctrl+C to stop)\")\n    try:\n        while True:\n            info = get_system_info()\n            display_info(info)\n            time.sleep(5)  # Update every 5 seconds\n    except KeyboardInterrupt:\n        print(\"\\nMonitor stopped\")\n\nif __name__ == '__main__':\n    main()\nEOF",
      "Run command: `pip3 install psutil`",
      "Run command: `chmod +x monitor.py`",
      "AGENT: ''",
      "AGENT: '--- Bonus: Python Script Template ---'",
      "Create tool: `cat > script_template.py << 'EOF'`",
      "#!/usr/bin/env python3\n'''\nScript: script_template.py\nDescription: Template for robust Python scripts\nAuthor: Your Name\nDate: 2025-10-08\n'''\n\nimport sys\nimport argparse\nimport logging\nfrom pathlib import Path\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('script.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\ndef main():\n    parser = argparse.ArgumentParser(description='Script description')\n    parser.add_argument('input', help='Input file')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')\n    \n    args = parser.parse_args()\n    \n    if args.verbose:\n        logger.setLevel(logging.DEBUG)\n    \n    try:\n        logger.info('Starting script')\n        # Your code here\n        logger.info('Script completed successfully')\n        return 0\n    except Exception as e:\n        logger.error(f'Script failed: {e}', exc_info=True)\n        return 1\n\nif __name__ == '__main__':\n    sys.exit(main())\nEOF",
      "AGENT: ''",
      "AGENT: '✓ SOLUTION SUMMARY:'",
      "AGENT: '  ✓ Ran shell commands with subprocess module.'",
      "AGENT: '  ✓ Performed file operations with pathlib.'",
      "AGENT: '  ✓ Created CLI tools with argparse for arguments.'",
      "AGENT: '  ✓ Processed JSON and CSV data formats.'",
      "AGENT: '  ✓ Made HTTP API requests with requests library.'",
      "AGENT: '  ✓ Parsed log files with regex patterns.'",
      "AGENT: '  ✓ Created backup script with compression.'",
      "AGENT: '  ✓ Built system monitor with psutil.'",
      "AGENT: '  ✓ Implemented proper error handling and logging.'",
      "AGENT: '  ✓ You now master Python for automation and system administration! 🐍'"
    ],
    "commands": ["python3", "pip3"],
    "packages": {
      "debian_ubuntu": ["python3", "python3-pip"],
      "arch": ["python", "python-pip"]
    },
    "related_commands": ["python", "pip", "virtualenv"],
    "complexity": "advanced",
    "tags": ["python", "scripting", "automation", "subprocess", "argparse", "json", "csv", "api", "file-processing", "pathlib"]
  }
]
