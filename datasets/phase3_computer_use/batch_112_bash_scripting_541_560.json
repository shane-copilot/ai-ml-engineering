[
  {
    "id": "scenario_shell_scripting_advanced_122",
    "command": "bash",
    "scenario": "Write robust shell scripts with error handling, functions, and best practices.",
    "problem": "Need to automate system tasks with shell scripts but scripts fail silently, don't handle errors properly, lack proper logging, and are difficult to maintain. Want to write production-quality bash scripts.",
    "solution": "Master advanced bash scripting: use set -euo pipefail for safety, implement functions, add proper error handling, create logging functions, handle command-line arguments, and follow shell script best practices.",
    "steps": [
      "USER SAYS: 'My bash scripts keep failing in unexpected ways and I don't know what went wrong. How do I write robust, production-quality shell scripts?'",
      "AGENT: 'Let me show you advanced bash scripting! We'll cover error handling, functions, logging, argument parsing, and best practices for reliable scripts.'",
      "AGENT: ''",
      "AGENT: '🔍 RESEARCH PHASE: Advanced shell scripting...'",
      "AGENT: '[Searching] \"bash script error handling functions best practices set -e\"'",
      "AGENT: '[Found] `set -euo pipefail` - exit on error, undefined vars, pipe failures.'",
      "AGENT: '[Found] Functions make scripts modular and reusable.'",
      "AGENT: '[Found] Always quote variables: \"$var\" not $var'",
      "AGENT: '[Found] Use `trap` for cleanup on exit/error.'",
      "AGENT: '✓ Research complete! Let's write professional scripts.'",
      "AGENT: ''",
      "AGENT: '--- Approach 1: Basic Script with Safety Options ---'",
      "Create tool: `cat > basic-script.sh << 'EOF'`",
      "#!/bin/bash\n# Exit on error, undefined variables, pipe failures\nset -euo pipefail\n\n# Script description\necho \"Starting backup process...\"\n\n# Variables (always use lowercase for local vars)\nbackup_dir=\"/backup\"\ndate_stamp=$(date +%Y%m%d)\n\n# Command that might fail\nif ! mkdir -p \"$backup_dir/$date_stamp\"; then\n    echo \"ERROR: Failed to create backup directory\" >&2\n    exit 1\nfi\n\necho \"Backup directory created: $backup_dir/$date_stamp\"\necho \"SUCCESS: Backup process completed\"\nEOF",
      "Run command: `chmod +x basic-script.sh`",
      "Run command: `./basic-script.sh`",
      "AGENT: 'Starting backup process...'",
      "AGENT: 'Backup directory created: /backup/20251008'",
      "AGENT: 'SUCCESS: Backup process completed'",
      "AGENT: ''",
      "AGENT: '--- Approach 2: Script with Functions ---'",
      "Create tool: `cat > functions-script.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Constants (uppercase for constants/globals)\nreadonly BACKUP_DIR=\"/backup\"\nreadonly LOG_FILE=\"/var/log/backup.log\"\nreadonly MAX_BACKUPS=7\n\n# Logging function\nlog() {\n    local level=\"$1\"\n    shift\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] [$level] $*\" | tee -a \"$LOG_FILE\"\n}\n\n# Error handling function\nerror_exit() {\n    log \"ERROR\" \"$1\"\n    exit \"${2:-1}\"  # Exit code defaults to 1\n}\n\n# Success message function\nsuccess() {\n    log \"INFO\" \"$*\"\n}\n\n# Check if running as root\nrequire_root() {\n    if [[ $EUID -ne 0 ]]; then\n        error_exit \"This script must be run as root\" 1\n    fi\n}\n\n# Create backup\ncreate_backup() {\n    local source=\"$1\"\n    local dest=\"$2\"\n    \n    log \"INFO\" \"Creating backup of $source to $dest\"\n    \n    if tar czf \"$dest\" \"$source\" 2>/dev/null; then\n        local size\n        size=$(du -h \"$dest\" | cut -f1)\n        success \"Backup created successfully ($size)\"\n        return 0\n    else\n        error_exit \"Failed to create backup\" 1\n    fi\n}\n\n# Clean old backups\nclean_old_backups() {\n    log \"INFO\" \"Cleaning backups older than $MAX_BACKUPS days\"\n    \n    local old_backups\n    old_backups=$(find \"$BACKUP_DIR\" -name \"backup_*.tar.gz\" -mtime +\"$MAX_BACKUPS\")\n    \n    if [[ -n \"$old_backups\" ]]; then\n        echo \"$old_backups\" | while read -r file; do\n            log \"INFO\" \"Deleting old backup: $file\"\n            rm \"$file\"\n        done\n    else\n        log \"INFO\" \"No old backups to clean\"\n    fi\n}\n\n# Main function\nmain() {\n    require_root\n    \n    local date_stamp\n    date_stamp=$(date +%Y%m%d_%H%M%S)\n    local backup_file=\"$BACKUP_DIR/backup_$date_stamp.tar.gz\"\n    \n    mkdir -p \"$BACKUP_DIR\"\n    \n    create_backup \"/var/www\" \"$backup_file\"\n    clean_old_backups\n    \n    success \"Backup process completed successfully\"\n}\n\n# Run main function\nmain \"$@\"\nEOF",
      "Run command: `chmod +x functions-script.sh`",
      "Run command: `sudo ./functions-script.sh`",
      "AGENT: '[2025-10-08 18:30:00] [INFO] Creating backup of /var/www to /backup/backup_20251008_183000.tar.gz'",
      "AGENT: '[2025-10-08 18:30:05] [INFO] Backup created successfully (45M)'",
      "AGENT: '[2025-10-08 18:30:05] [INFO] Cleaning backups older than 7 days'",
      "AGENT: '[2025-10-08 18:30:05] [INFO] Deleting old backup: /backup/backup_20251001_120000.tar.gz'",
      "AGENT: '[2025-10-08 18:30:05] [INFO] Backup process completed successfully'",
      "AGENT: ''",
      "AGENT: '✅ Professional script with functions, logging, and error handling!'",
      "AGENT: ''",
      "AGENT: '--- Approach 3: Cleanup with trap ---'",
      "Create tool: `cat > cleanup-trap.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Temporary file\nTEMP_FILE=$(mktemp)\n\n# Cleanup function\ncleanup() {\n    local exit_code=$?\n    echo \"Cleaning up...\"\n    rm -f \"$TEMP_FILE\"\n    if [[ $exit_code -ne 0 ]]; then\n        echo \"Script failed with exit code $exit_code\"\n    fi\n    exit $exit_code\n}\n\n# Register cleanup on exit (normal or error)\ntrap cleanup EXIT\ntrap cleanup INT TERM\n\necho \"Working with temporary file: $TEMP_FILE\"\necho \"Some data\" > \"$TEMP_FILE\"\n\n# Simulate error\nif [[ \"${1:-}\" == \"--fail\" ]]; then\n    echo \"Simulating failure...\"\n    false  # This will trigger cleanup\nfi\n\necho \"Script completed successfully\"\nEOF",
      "Run command: `chmod +x cleanup-trap.sh`",
      "Run command: `./cleanup-trap.sh`",
      "AGENT: 'Working with temporary file: /tmp/tmp.xyz123'",
      "AGENT: 'Script completed successfully'",
      "AGENT: 'Cleaning up...'",
      "AGENT: ''",
      "Run command: `./cleanup-trap.sh --fail`",
      "AGENT: 'Working with temporary file: /tmp/tmp.abc456'",
      "AGENT: 'Simulating failure...'",
      "AGENT: 'Cleaning up...'",
      "AGENT: 'Script failed with exit code 1'",
      "AGENT: ''",
      "AGENT: '✅ Cleanup happens even on error!'",
      "AGENT: ''",
      "AGENT: '--- Approach 4: Command-Line Argument Parsing ---'",
      "Create tool: `cat > args-parsing.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Default values\nVERBOSE=false\nOUTPUT_DIR=\".\"\nINPUT_FILE=\"\"\n\n# Usage function\nusage() {\n    cat << USAGE\nUsage: $(basename \"$0\") [OPTIONS] -i INPUT_FILE\n\nProcess a file with various options.\n\nOPTIONS:\n    -i, --input FILE     Input file (required)\n    -o, --output DIR     Output directory (default: current directory)\n    -v, --verbose        Enable verbose mode\n    -h, --help           Show this help message\n\nEXAMPLES:\n    $(basename \"$0\") -i input.txt\n    $(basename \"$0\") -i input.txt -o /output -v\nUSAGE\n    exit 1\n}\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case \"$1\" in\n        -i|--input)\n            INPUT_FILE=\"$2\"\n            shift 2\n            ;;\n        -o|--output)\n            OUTPUT_DIR=\"$2\"\n            shift 2\n            ;;\n        -v|--verbose)\n            VERBOSE=true\n            shift\n            ;;\n        -h|--help)\n            usage\n            ;;\n        *)\n            echo \"ERROR: Unknown option: $1\" >&2\n            usage\n            ;;\n    esac\ndone\n\n# Validate required arguments\nif [[ -z \"$INPUT_FILE\" ]]; then\n    echo \"ERROR: Input file is required\" >&2\n    usage\nfi\n\nif [[ ! -f \"$INPUT_FILE\" ]]; then\n    echo \"ERROR: Input file does not exist: $INPUT_FILE\" >&2\n    exit 1\nfi\n\n# Verbose logging\nlog_verbose() {\n    if [[ \"$VERBOSE\" == true ]]; then\n        echo \"[VERBOSE] $*\"\n    fi\n}\n\n# Main logic\nlog_verbose \"Input file: $INPUT_FILE\"\nlog_verbose \"Output directory: $OUTPUT_DIR\"\nlog_verbose \"Processing file...\"\n\necho \"Processing: $INPUT_FILE\"\necho \"Output will be saved to: $OUTPUT_DIR\"\necho \"SUCCESS: File processed\"\nEOF",
      "Run command: `chmod +x args-parsing.sh`",
      "Run command: `echo \"test data\" > test.txt`",
      "Run command: `./args-parsing.sh -i test.txt -v`",
      "AGENT: '[VERBOSE] Input file: test.txt'",
      "AGENT: '[VERBOSE] Output directory: .'",
      "AGENT: '[VERBOSE] Processing file...'",
      "AGENT: 'Processing: test.txt'",
      "AGENT: 'Output will be saved to: .'",
      "AGENT: 'SUCCESS: File processed'",
      "AGENT: ''",
      "Run command: `./args-parsing.sh --help`",
      "AGENT: 'Usage: args-parsing.sh [OPTIONS] -i INPUT_FILE'",
      "AGENT: ''",
      "AGENT: 'Process a file with various options.'",
      "AGENT: ''",
      "AGENT: 'OPTIONS:'",
      "AGENT: '    -i, --input FILE     Input file (required)'",
      "AGENT: '    -o, --output DIR     Output directory (default: current directory)'",
      "AGENT: '    -v, --verbose        Enable verbose mode'",
      "AGENT: '    -h, --help           Show this help message'",
      "AGENT: ''",
      "AGENT: '--- Approach 5: Arrays and Loops ---'",
      "Create tool: `cat > arrays-loops.sh << 'EOF'`",
      "#!/bin/bash\nset -euo pipefail\n\n# Array declaration\nservers=(\"web1.example.com\" \"web2.example.com\" \"web3.example.com\")\nports=(80 443 8080)\n\necho \"=== Iterate over array ===\"\nfor server in \"${servers[@]}\"; do\n    echo \"Checking server: $server\"\ndone\n\necho \"\"\necho \"=== Array with indices ===\"\nfor i in \"${!servers[@]}\"; do\n    echo \"Server $i: ${servers[$i]}\"\ndone\n\necho \"\"\necho \"=== Associative array (dictionary) ===\"\ndeclare -A config\nconfig[\"database\"]=\"postgres\"\nconfig[\"cache\"]=\"redis\"\nconfig[\"queue\"]=\"rabbitmq\"\n\nfor key in \"${!config[@]}\"; do\n    echo \"$key = ${config[$key]}\"\ndone\n\necho \"\"\necho \"=== Check if element exists ===\"\nif [[ \" ${servers[*]} \" =~ \" web2.example.com \" ]]; then\n    echo \"web2.example.com found in array\"\nfi\n\necho \"\"\necho \"=== Array length ===\"\necho \"Number of servers: ${#servers[@]}\"\nEOF",
      "Run command: `chmod +x arrays-loops.sh`",
      "Run command: `./arrays-loops.sh`",
      "AGENT: '=== Iterate over array ==='",
      "AGENT: 'Checking server: web1.example.com'",
      "AGENT: 'Checking server: web2.example.com'",
      "AGENT: 'Checking server: web3.example.com'",
      "AGENT: ''",
      "AGENT: '=== Array with indices ==='",
      "AGENT: 'Server 0: web1.example.com'",
      "AGENT: 'Server 1: web2.example.com'",
      "AGENT: 'Server 2: web3.example.com'",
      "AGENT: ''",
      "AGENT: '=== Associative array (dictionary) ==='",
      "AGENT: 'database = postgres'",
      "AGENT: 'cache = redis'",
      "AGENT: 'queue = rabbitmq'",
      "AGENT: ''",
      "AGENT: '=== Check if element exists ==='",
      "AGENT: 'web2.example.com found in array'",
      "AGENT: ''",
      "AGENT: '=== Array length ==='",
      "AGENT: 'Number of servers: 3'",
      "AGENT: ''",
      "AGENT: '--- Bonus: Best Practices Checklist ---'",
      "AGENT: ''",
      "AGENT: '✅ 1. Always use set -euo pipefail'",
      "AGENT: '   - set -e: Exit on error'",
      "AGENT: '   - set -u: Exit on undefined variable'",
      "AGENT: '   - set -o pipefail: Catch pipe errors'",
      "AGENT: ''",
      "AGENT: '✅ 2. Quote all variables: \"$var\" not $var'",
      "AGENT: '   - Prevents word splitting and glob expansion'",
      "AGENT: ''",
      "AGENT: '✅ 3. Use [[ ]] instead of [ ]'",
      "AGENT: '   - More powerful and safer'",
      "AGENT: ''",
      "AGENT: '✅ 4. Check command success explicitly'",
      "AGENT: '   - if command; then ... fi'",
      "AGENT: '   - command || error_exit \"Failed\"'",
      "AGENT: ''",
      "AGENT: '✅ 5. Use functions for reusability'",
      "AGENT: '   - Keep main logic in main() function'",
      "AGENT: ''",
      "AGENT: '✅ 6. Add cleanup with trap'",
      "AGENT: '   - trap cleanup EXIT'",
      "AGENT: ''",
      "AGENT: '✅ 7. Use readonly for constants'",
      "AGENT: '   - readonly MAX_RETRIES=3'",
      "AGENT: ''",
      "AGENT: '✅ 8. Validate input early'",
      "AGENT: '   - Check required arguments'",
      "AGENT: '   - Validate file existence'",
      "AGENT: ''",
      "AGENT: '✅ 9. Use mktemp for temporary files'",
      "AGENT: '   - TEMP=$(mktemp)'",
      "AGENT: ''",
      "AGENT: '✅ 10. Add comprehensive logging'",
      "AGENT: '   - Log timestamps, levels, and context'",
      "AGENT: ''",
      "AGENT: '✓ SOLUTION SUMMARY:'",
      "AGENT: '  ✓ Used set -euo pipefail for robust error handling.'",
      "AGENT: '  ✓ Created modular scripts with functions.'",
      "AGENT: '  ✓ Implemented logging with timestamps and levels.'",
      "AGENT: '  ✓ Added cleanup handlers with trap.'",
      "AGENT: '  ✓ Parsed command-line arguments professionally.'",
      "AGENT: '  ✓ Used arrays and loops for data processing.'",
      "AGENT: '  ✓ Followed shell scripting best practices.'",
      "AGENT: '  ✓ You now write production-quality bash scripts! 🐚'"
    ],
    "commands": ["bash", "chmod", "mktemp", "trap", "set"],
    "packages": {
      "debian_ubuntu": ["bash"],
      "arch": ["bash"]
    },
    "related_commands": ["sh", "zsh", "fish"],
    "complexity": "advanced",
    "tags": ["bash", "shell-scripting", "automation", "error-handling", "functions", "best-practices", "logging", "argument-parsing"]
  }
]
